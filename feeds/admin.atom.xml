<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ian Bicking: a blog - Admin</title><link href="https://www.ianbicking.org/" rel="alternate"></link><link href="https://www.ianbicking.org/feeds/admin.atom.xml" rel="self"></link><id>https://www.ianbicking.org/</id><updated>2012-10-02T21:26:00-05:00</updated><entry><title>Why doctest.js is better than Python’s doctest</title><link href="https://www.ianbicking.org/blog/2012/10/why-doctestjs-is-better-than-pythons-doctest.html" rel="alternate"></link><published>2012-10-02T21:26:00-05:00</published><updated>2012-10-02T21:26:00-05:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2012-10-02:/blog/2012/10/why-doctestjs-is-better-than-pythons-doctest.html</id><summary type="html">&lt;p&gt;I&amp;#8217;ve been trying, not too successfully I&amp;#8217;m afraid, to get more people to use &lt;a class="reference external" href="http://doctestjs.org"&gt;doctest.js&lt;/a&gt;.  There&amp;#8217;s probably a few reasons people don&amp;#8217;t.  They are all wrong!  Doctest.js is the&amp;nbsp;best!&lt;/p&gt;
&lt;p&gt;One issue in particular is that people (especially people in my Python-biased circles) are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I&amp;#8217;ve been trying, not too successfully I&amp;#8217;m afraid, to get more people to use &lt;a class="reference external" href="http://doctestjs.org"&gt;doctest.js&lt;/a&gt;.  There&amp;#8217;s probably a few reasons people don&amp;#8217;t.  They are all wrong!  Doctest.js is the&amp;nbsp;best!&lt;/p&gt;
&lt;p&gt;One issue in particular is that people (especially people in my Python-biased circles) are perhaps thrown off by Python&amp;#8217;s doctest.  I think Python&amp;#8217;s doctest is pretty nice, I enjoy testing with it, but there&amp;#8217;s no question that it has a lot of problems.  I&amp;#8217;ve even thought about trying to fix doctest, and even made a repository, but I only really got as far as &lt;a class="reference external" href="https://github.com/ianb/doctest2/issues?direction=desc&amp;amp;sort=created&amp;amp;state=open"&gt;creating a list of issues I&amp;#8217;d like to fix&lt;/a&gt;. But, like so many before me, I never actually &lt;em&gt;made&lt;/em&gt; those fixes. Doctest has, in its life, only really had a single period of improvement (in the time leading to Python 2.4).  That&amp;#8217;s not a recipe for&amp;nbsp;success.&lt;/p&gt;
&lt;p&gt;Of course doctest.js takes inspiration from Python&amp;#8217;s doctest, but I wrote it as a real test environment, not for a minimal use case.  In the process I fixed a bunch of issues with doctest, and in places Javascript has also provided helpful&amp;nbsp;usability.&lt;/p&gt;
&lt;p&gt;Some&amp;nbsp;issues:&lt;/p&gt;
&lt;div class="section" id="doctest-js-output-is-predictable"&gt;
&lt;h2&gt;Doctest.js output is&amp;nbsp;predictable&lt;/h2&gt;
&lt;p&gt;The classic pitfall of Python&amp;#8217;s doctest is printing a&amp;nbsp;dictionary:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; print {&amp;quot;one&amp;quot;: 1, &amp;quot;two&amp;quot;: 2}
{'two': 2, 'one': 1}
&lt;/pre&gt;
&lt;p&gt;The print order of a dictionary is arbitrary, based on a hash algorithm that can change, or mix things up as items are added or removed.  And to make it worse, the output &lt;em&gt;usually&lt;/em&gt; stable, such that you can write tests that unexpectibly fragile.  But there&amp;#8217;s no reason why &lt;tt class="docutils literal"&gt;dict.__repr__&lt;/tt&gt; &lt;em&gt;must&lt;/em&gt; use an arbitrary order.  Personally I take it as a bit of unfortunate&amp;nbsp;laziness.&lt;/p&gt;
&lt;p&gt;If doctest had used &lt;tt class="docutils literal"&gt;pprint&lt;/tt&gt; for all of its printing it would have helped some.  But not enough, because this kind of code is fairly&amp;nbsp;common:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def __repr__(self):
    return '&amp;lt;ThisClass attr=%r&amp;gt;' % self.attr
&lt;/pre&gt;
&lt;p&gt;and that &lt;tt class="docutils literal"&gt;%r&lt;/tt&gt; invokes a &lt;tt class="docutils literal"&gt;repr()&lt;/tt&gt; that cannot be&amp;nbsp;overridden.&lt;/p&gt;
&lt;p&gt;In doctest.js I always try to make output predictable.  One reason this is fairly easy is that there&amp;#8217;s nothing like &lt;tt class="docutils literal"&gt;repr()&lt;/tt&gt; in Javascript, so doctest.js has its own implementation.  It&amp;#8217;s like I started with pprint and no other notion&amp;nbsp;existed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="good-matching"&gt;
&lt;h2&gt;Good&amp;nbsp;matching&lt;/h2&gt;
&lt;p&gt;In addition to unpredictable output, there&amp;#8217;s also just hard-to-match output.  Output might contain blank lines, for instance, and Python&amp;#8217;s doctest requires a very ugly &lt;tt class="docutils literal"&gt;&amp;lt;&lt;span class="caps"&gt;BLANKLINE&lt;/span&gt;&amp;gt;&lt;/tt&gt; token to handle that. Whitespace might not be normalized.  Maybe there&amp;#8217;s boring output. Maybe there&amp;#8217;s just a volatile item like a&amp;nbsp;timestamp.&lt;/p&gt;
&lt;p&gt;Doctest.js includes, by default, ellipsis: &lt;tt class="docutils literal"&gt;...&lt;/tt&gt; matches any length of text.  But it also includes another wildcard, &lt;tt class="docutils literal"&gt;?&lt;/tt&gt;, which matches just one number or word.  This avoids cases when the use of &lt;tt class="docutils literal"&gt;...&lt;/tt&gt; swallows up too much when you just wanted to get a single&amp;nbsp;word.&lt;/p&gt;
&lt;p&gt;Also doctest.js doesn&amp;#8217;t use &lt;tt class="docutils literal"&gt;...&lt;/tt&gt; for other purposes.  In Python&amp;#8217;s doctest &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;...`&lt;/span&gt;&lt;/tt&gt; is used for continuation lines, meaning you can&amp;#8217;t just ignore output,&amp;nbsp;like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; print who_knows_what_this_returns()
...
&lt;/pre&gt;
&lt;p&gt;Or even worse, you can&amp;#8217;t ignore the beginning of an&amp;nbsp;item:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; print some_request
...
X-Some-Header: foo
...
&lt;/pre&gt;
&lt;p&gt;The way I prefer to use doctest.js it doesn&amp;#8217;t have &lt;em&gt;any&lt;/em&gt; continuation line symbol (but if there is one, it&amp;#8217;s &lt;tt class="docutils literal"&gt;&amp;gt;&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;Also doctest.js normalizes whitespace, normalizes &lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;'&lt;/tt&gt;, and just generally tries to be &lt;em&gt;reasonable&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="doctest-js-tests-are-plain-javascript"&gt;
&lt;h2&gt;Doctest.js tests are plain&amp;nbsp;Javascript&lt;/h2&gt;
&lt;p&gt;Not many editors know how to syntax highlight and check doctests, with their &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/tt&gt; in front of each line and so forth.  And the whole thing is tweaky, you need to use a continuation (&lt;tt class="docutils literal"&gt;...&lt;/tt&gt;) on some lines, and start statements with &lt;tt class="docutils literal"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/tt&gt;.  It&amp;#8217;s an awkward way to&amp;nbsp;compose.&lt;/p&gt;
&lt;p&gt;Doctest.js started out with the same notion, though with different symbols (&lt;tt class="docutils literal"&gt;$&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&amp;gt;&lt;/tt&gt;).  But recently with the rise of a number of excellent parsers (I used &lt;a class="reference external" href="http://esprima.org/"&gt;Esprima&lt;/a&gt;) I&amp;#8217;ve moved my own tests to another&amp;nbsp;pattern:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
print(something())
// =&amp;gt; expected output
&lt;/pre&gt;
&lt;p&gt;This is already a fairly common way to write examples.  Like how you may have read pre-Python pseudocode and thought: &lt;em&gt;that looks like Python!&lt;/em&gt;: doctest.js looks like example&amp;nbsp;pseudocode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="doctest-js-tests-are-self-describing"&gt;
&lt;h2&gt;Doctest.js tests are&amp;nbsp;self-describing&lt;/h2&gt;
&lt;p&gt;Python&amp;#8217;s doctest has some options, some &lt;em&gt;important&lt;/em&gt; options that effect the semantics of the test, that you can only turn on in the runner.  The most important option is &lt;span class="caps"&gt;ELLIPSIS&lt;/span&gt;.  Either your test was written to use &lt;span class="caps"&gt;ELLIPSIS&lt;/span&gt; or it wasn&amp;#8217;t - that a test can&amp;#8217;t self-describe its requirements means that test running is&amp;nbsp;fragile.&lt;/p&gt;
&lt;p&gt;I made &lt;a class="reference external" href="http://pypi.python.org/pypi/dtopt"&gt;the hackiest package ever&lt;/a&gt; to get around this in Python, but it&amp;#8217;s hacky and&amp;nbsp;lame.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exception-handling-isn-t-special"&gt;
&lt;h2&gt;Exception handling isn&amp;#8217;t&amp;nbsp;special&lt;/h2&gt;
&lt;p&gt;Python&amp;#8217;s doctest treats exceptions differently from other output.  So if you print something before the exception, it is thrown away, never to be seen.  And you can&amp;#8217;t use some of the same matching&amp;nbsp;techniques.&lt;/p&gt;
&lt;p&gt;Doctest.js just prints out exceptions, and it&amp;#8217;s matched like anything&amp;nbsp;else.&lt;/p&gt;
&lt;p&gt;This particular case is one of several places where it feels like Python&amp;#8217;s doctest is just being obstinate.  Doing it the right way isn&amp;#8217;t harder.  Python&amp;#8217;s doctest makes &lt;em&gt;debugging&lt;/em&gt; exception cases really&amp;nbsp;hard.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="doctest-js-has-a-concept-of-abort"&gt;
&lt;h2&gt;Doctest.js has a concept of&amp;nbsp;&amp;#8220;abort&amp;#8221;&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m actually pretty okay with Python doctest&amp;#8217;s notion that you just run all the tests, even when one fails.  Getting too many failures is a bit of a nuisance, but it&amp;#8217;s not &lt;em&gt;that bad&lt;/em&gt;.  But there&amp;#8217;s no way to just give up, and there needs to be.  If you are relying on something to be importable, or some service to be available, there&amp;#8217;s no point in going on with the&amp;nbsp;tests.&lt;/p&gt;
&lt;p&gt;Doctest.js lets you call &lt;tt class="docutils literal"&gt;Abort()&lt;/tt&gt; and further tests are&amp;nbsp;cancelled.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="distinguishing-between-debugging-output-and-deliberate-output"&gt;
&lt;h2&gt;Distinguishing between debugging output and deliberate&amp;nbsp;output&lt;/h2&gt;
&lt;p&gt;Maybe it&amp;#8217;s my own fault for being a programming troglodite, but I use a lot of &lt;tt class="docutils literal"&gt;print&lt;/tt&gt; for debugging.  This becomes a real problem with Python&amp;#8217;s doctest, as it tracks all that printing and it causes tests to&amp;nbsp;fail.&lt;/p&gt;
&lt;p&gt;Javascript has something &lt;em&gt;specifically for&lt;/em&gt; printing debugging output: &lt;tt class="docutils literal"&gt;console.log()&lt;/tt&gt;.  Doctest.js doesn&amp;#8217;t mess with that, it adds a new function &lt;tt class="docutils literal"&gt;print()&lt;/tt&gt;.  Only stuff that is printed (not logged) is treated as expected output.  It&amp;#8217;s like &lt;tt class="docutils literal"&gt;console.log()&lt;/tt&gt; goes to stderr and &lt;tt class="docutils literal"&gt;print()&lt;/tt&gt; goes to&amp;nbsp;stdout.&lt;/p&gt;
&lt;p&gt;Doctest.js also forces the developer to print everything they care about.  For better or worse Javascript has many more expressions than Python (including assignments), so looking at the result of an expression isn&amp;#8217;t a good clue for whether you &lt;em&gt;care&lt;/em&gt; about the result of an expression.  I&amp;#8217;m not sure this is &lt;em&gt;better&lt;/em&gt;, but it&amp;#8217;s part of the&amp;nbsp;difference.&lt;/p&gt;
&lt;p&gt;Doctest.js also groups your printed statements according to the example you are in (an example being a block of code and an expected output).  This is much more helpful than watching a giant stream of output go to the console (the browser console or&amp;nbsp;terminal).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="doctest-js-handles-async-code"&gt;
&lt;h2&gt;Doctest.js handles async&amp;nbsp;code&lt;/h2&gt;
&lt;p&gt;This admittedly isn&amp;#8217;t that big a deal for Python, but for Javascript it is a real problem.  Not a problem for doctest.js in particular, but a problem for any Javascript test framework.  You want to test return values, but lots of functions don&amp;#8217;t &amp;#8220;return&amp;#8221;, instead they call some callback or create some kind of promise object, and you have to test for side&amp;nbsp;effects.&lt;/p&gt;
&lt;p&gt;Doctest.js I think has a &lt;a class="reference external" href="http://doctestjs.org/tutorial.html#async"&gt;really great answer for this&lt;/a&gt;, which is not so much to say that Python&amp;#8217;s doctest is so much worse, but in the context of Javascript doctest.js has something really useful and unique.  If callback-driven async code had ever been very popular in Python then this sort of feature would be nice there&amp;nbsp;too.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-browser-is-a-great-environment"&gt;
&lt;h2&gt;The browser is a great&amp;nbsp;environment&lt;/h2&gt;
&lt;p&gt;A lot of where doctest.js is much better than Python&amp;#8217;s doctest is simply that it has a much more powerful environment for displaying results.  It can highlight failed or passing tests.  When there&amp;#8217;s a wildcard in expected output, it can show the actual output without adding any particular extra distraction.  It can group console messages with the tests they go with.  It can show &lt;em&gt;both&lt;/em&gt; a simple failure message, and a detailed line-by-line comparison.  All these details make it easy to identify what went wrong and fix it.  The browser gives a rich and navigable&amp;nbsp;interface.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;d &lt;em&gt;like&lt;/em&gt; to get doctest.js working well on Node.js (right now it works, but is not appealing), but I just can&amp;#8217;t bring myself to give up the browser.  I have to figure out a good&amp;nbsp;hybrid.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-s-doctest-lacks-a-champion"&gt;
&lt;h2&gt;Python&amp;#8217;s doctest lacks a&amp;nbsp;champion&lt;/h2&gt;
&lt;p&gt;This is ultimately the reason Python&amp;#8217;s doctest has all these problems: no one cares about it, no one feels responsible for it, and no one feels empowered to make improvements to it.  And to make things worse there is a cadre of people that will respond to suggestions with their own criticisms that doctest should never be used beyond its original niche, that it&amp;#8217;s constraints are&amp;nbsp;features.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="doctest-is-still-great"&gt;
&lt;h2&gt;Doctest is still&amp;nbsp;great&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m ragging on Python&amp;#8217;s doctest only because I love it.  I wish it was better, and I made doctest.js in a way I wish Python&amp;#8217;s doctest was made.  Doctest, and more generally example/expectation oriented code, is a great way to explain things, to make tests readable, to make test-driven development feasible, to create an environment that errs on the side of over-testing instead of under-testing, and to make failures and resolutions symmetric.  It&amp;#8217;s still &lt;a class="reference external" href="http://blog.ianbicking.org/behavior-driven-programming.html"&gt;vastly superior to &lt;span class="caps"&gt;BDD&lt;/span&gt;&lt;/a&gt;, avoiding all &lt;span class="caps"&gt;BDD&lt;/span&gt;&amp;#8217;s aping of readability while still embracing the sense of&amp;nbsp;test-as-narrative.&lt;/p&gt;
&lt;p&gt;But, more to the point: &lt;a class="reference external" href="http://doctestjs.org"&gt;use doctest.js&lt;/a&gt;, &lt;a class="reference external" href="http://doctestjs.org/tutorial.html"&gt;read the tutorial&lt;/a&gt;, or &lt;a class="reference external" href="http://doctestjs.org/try.html"&gt;try it in the browser&lt;/a&gt;.  I swear, it&amp;#8217;s &lt;em&gt;really nice to use&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Javascript"></category><category term="Mozilla"></category><category term="Programming"></category><category term="Python"></category></entry><entry><title>Python Application Package</title><link href="https://www.ianbicking.org/blog/2012/02/python-application-package.html" rel="alternate"></link><published>2012-02-29T18:12:00-06:00</published><updated>2012-02-29T18:12:00-06:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2012-02-29:/blog/2012/02/python-application-package.html</id><summary type="html">&lt;p&gt;I&amp;#8217;ve been thinking some more about deployment of Python web applications, and deployment in general (in part leading up to the &lt;a class="reference external" href="https://us.pycon.org/2012/community/WebDevSummit/"&gt;Web Summit&lt;/a&gt;). And I&amp;#8217;ve got an&amp;nbsp;idea.&lt;/p&gt;
&lt;p&gt;I &lt;a class="reference external" href="http://blog.ianbicking.org/2011/03/31/python-webapp-package/"&gt;wrote about this about a year ago&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/ianb/pywebapp/blob/master/docs/spec.txt"&gt;recently revised some notes on a proposal&lt;/a&gt; but I&amp;#8217;ve been …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I&amp;#8217;ve been thinking some more about deployment of Python web applications, and deployment in general (in part leading up to the &lt;a class="reference external" href="https://us.pycon.org/2012/community/WebDevSummit/"&gt;Web Summit&lt;/a&gt;). And I&amp;#8217;ve got an&amp;nbsp;idea.&lt;/p&gt;
&lt;p&gt;I &lt;a class="reference external" href="http://blog.ianbicking.org/2011/03/31/python-webapp-package/"&gt;wrote about this about a year ago&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/ianb/pywebapp/blob/master/docs/spec.txt"&gt;recently revised some notes on a proposal&lt;/a&gt; but I&amp;#8217;ve been thinking about something a bit more basic: a way to simply ship server applications, bundles of code.  Web applications are just one use case for&amp;nbsp;this.&lt;/p&gt;
&lt;p&gt;For now lets call this a &amp;#8220;Python application package&amp;#8221;.  It has these&amp;nbsp;features:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;There is an &lt;em&gt;application description&lt;/em&gt;: this tells the &lt;em&gt;environment&lt;/em&gt; about the application.  (This is sometimes called &amp;#8220;configuration&amp;#8221; but that term is very confusing and overloaded; I think &amp;#8220;description&amp;#8221; is much&amp;nbsp;clearer.)&lt;/li&gt;
&lt;li&gt;Given the description, you can create an execution environment to run code from the application and acquire objects from the application.  So there would be a specific way to setup &lt;tt class="docutils literal"&gt;sys.path&lt;/tt&gt;, and a way to indicate any libraries that are required but not bundled directly with the&amp;nbsp;application.&lt;/li&gt;
&lt;li&gt;The environment can inject information into the application.  (Also this sort of thing is sometimes called &amp;#8220;configuration&amp;#8221;, but let&amp;#8217;s not do that either.)  This is where the environment could indicate, for instance, what database the application should connect to (host, username,&amp;nbsp;etc).&lt;/li&gt;
&lt;li&gt;There would be a way to run commands and get objects from the application.  The environment would look in the application description to get the names of commands or objects, and use them in some specific manner depending on the purpose of the application.  For instance, &lt;span class="caps"&gt;WSGI&lt;/span&gt; web applications would point the environment to an application object.  A Tornado application might simply have a command to start itself (with the environment indicating what port to use through its&amp;nbsp;injection).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There&amp;#8217;s a lot of things you can build from these pieces, and in a sophisticated application you might use a bunch of them at once.  You might have some &lt;span class="caps"&gt;WSGI&lt;/span&gt;, maybe a seperate non-&lt;span class="caps"&gt;WSGI&lt;/span&gt; server to handle Web Sockets, something for a Celery queue, a way to accept incoming email, etc.  In pretty much all cases I think basic application lifecycle is needed: commands to run when an application is first installed, something to verify the environment is acceptable, when you want to back up its data, when you want to uninstall&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s also some things that all environments should setup the same or inject into the application.  E.g., &lt;tt class="docutils literal"&gt;$&lt;span class="caps"&gt;TMPDIR&lt;/span&gt;&lt;/tt&gt; should point to a place where the application can keep its temporary files.  Or, every application should have a directory (perhaps specified in another environmental variable) where it can write log&amp;nbsp;files.&lt;/p&gt;
&lt;div class="section" id="details"&gt;
&lt;h2&gt;Details?&lt;/h2&gt;
&lt;p&gt;To get more concrete, here&amp;#8217;s what I can imagine from a small application description; probably &lt;span class="caps"&gt;YAML&lt;/span&gt; would be a good&amp;nbsp;format:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
platform: python, wsgi
require:
  os: posix
  python: &amp;lt;3
  rpm: m2crypto
  deb: python-m2crypto
  pip: requirements.txt
python:
  paths: vendor/
wsgi:
  app: myapp.wsgiapp:application
&lt;/pre&gt;
&lt;p&gt;I imagine &lt;tt class="docutils literal"&gt;platform&lt;/tt&gt; as kind of a series of mixins.  This system doesn&amp;#8217;t really need to be Python-specific; when creating something similar for &lt;a class="reference external" href="http://cloudsilverlining.org"&gt;Silver Lining&lt;/a&gt; I found &lt;span class="caps"&gt;PHP&lt;/span&gt; support relatively easy to add (handling languages that aren&amp;#8217;t naturally portable, like Go, might be more of a stretch).  So &lt;tt class="docutils literal"&gt;python&lt;/tt&gt; is one of the features this application uses.  You can imagine lots of modularization for other features, but it would be easy and unproductive to get distracted by&amp;nbsp;that.&lt;/p&gt;
&lt;p&gt;The application has certain requirements of its environment, like the version of Python and the general &lt;span class="caps"&gt;OS&lt;/span&gt; type.  The application might also require libraries, ideally one libraries that are not portable (M2Crypto being an example).  Modern package management works pretty nicely for this stuff, so relying on system packages as a first try I believe is best (I&amp;#8217;d offer &lt;tt class="docutils literal"&gt;requirements.txt&lt;/tt&gt; as a fallback, not as the primary way to handle&amp;nbsp;dependencies).&lt;/p&gt;
&lt;p&gt;I think it&amp;#8217;s much more reliable if applications primarily rely on bundling their dependencies directly (i.e., using a vendor directory). The tool support for this is a bit spotty, but I believe this package format could clarify the problems and solutions.  &lt;a class="reference external" href="https://gist.github.com/1368649"&gt;Here is an example&lt;/a&gt; of how you might set up a virtualenv environment for &lt;em&gt;managing&lt;/em&gt; vendor libraries (you then do not need virtualenv to &lt;em&gt;use&lt;/em&gt; those same libraries), and do so in a way where you can check the results into source control.  It&amp;#8217;s kind of complicated, but works (well, almost works - &lt;tt class="docutils literal"&gt;bin/&lt;/tt&gt; files need fixing up).  It&amp;#8217;s a start at&amp;nbsp;least.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="support-library"&gt;
&lt;h2&gt;Support&amp;nbsp;Library&lt;/h2&gt;
&lt;p&gt;On the environment side we need a good support library.  &lt;a class="reference external" href="https://github.com/ianb/pywebapp/"&gt;pywebapp&lt;/a&gt; has some of the basic features, though it is quite incomplete. I imagine a library looking something like&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
from apppackage import AppPackage
app = AppPackage('/var/apps/app1.2012.02.11')
# Maybe a little Debian support directly:
subprocess.call(['apt-get', 'install'] +
                app.config['require']['deb'])
# Or fall back of virtualenv/pip
app.create_virtualenv('/var/app/venvs/app1.2012.02.11')
app.install_pip_requirements()
wsgi_app = app.load_object(app.config['wsgi']['app'])
&lt;/pre&gt;
&lt;p&gt;You can imagine building hosting services on this sort of thing, or setting up continuous integration servers (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;app.run_command(app.config['unit_test'])&lt;/span&gt;&lt;/tt&gt;), and so&amp;nbsp;forth.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="local-development"&gt;
&lt;h2&gt;Local&amp;nbsp;Development&lt;/h2&gt;
&lt;p&gt;If designed properly, I think this format is as usable for local development as it is for deployment.  It should be able to run directly from a checkout, with the &amp;#8220;development environment&amp;#8221; being an environment just like any&amp;nbsp;other.&lt;/p&gt;
&lt;p&gt;This rules out, or at least makes less exciting, the use of zip files or tarballs as a package format.  The only justification I see for using such archives is that they are easy to move around; but we live in the &lt;span class="caps"&gt;FUTURE&lt;/span&gt; and there are many ways to move directories around and we don&amp;#8217;t need to cater to silly old fashions.  If that means a script that creates a tarball, FTPs it to another computer, and there it is unzipped, then fine - this format &lt;em&gt;should not&lt;/em&gt; specify anything about how you actually deliver the files.  But let&amp;#8217;s not worry about copying &lt;a class="reference external" href="http://en.wikipedia.org/wiki/WAR_file_format_%28Sun%29"&gt;WARs&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Packaging"></category><category term="Python"></category><category term="Silver Lining"></category><category term="Web"></category></entry><entry><title>Git-as-sync, not source-control-as-deployment</title><link href="https://www.ianbicking.org/blog/2012/02/git-as-sync-not-source-control-as-deployment.html" rel="alternate"></link><published>2012-02-14T02:30:00-06:00</published><updated>2012-02-14T02:30:00-06:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2012-02-14:/blog/2012/02/git-as-sync-not-source-control-as-deployment.html</id><summary type="html">&lt;p&gt;I don&amp;#8217;t like systems that use &lt;tt class="docutils literal"&gt;git push&lt;/tt&gt; for deployment (Heroku et al).  Why?  I do a lot of&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git push deploy
... realize I forgot a domain name ...
$ git commit -m &amp;quot;fix domain name&amp;quot; -a ; git push deploy
... realize I didn't do something right with the database setup …&lt;/pre&gt;</summary><content type="html">&lt;p&gt;I don&amp;#8217;t like systems that use &lt;tt class="docutils literal"&gt;git push&lt;/tt&gt; for deployment (Heroku et al).  Why?  I do a lot of&amp;nbsp;this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git push deploy
... realize I forgot a domain name ...
$ git commit -m &amp;quot;fix domain name&amp;quot; -a ; git push deploy
... realize I didn't do something right with the database setup ...
$ git commit -m &amp;quot;configure database right&amp;quot; -a ; git push deploy
... dammit, I didn't fix it quite right ...
$ git commit -m &amp;quot;typo&amp;quot; -a ; git push deploy
&lt;/pre&gt;
&lt;p&gt;And then maybe I&amp;#8217;d actually like to keep my config out of my source control, or have a build process that I run locally, or any number of things.  I&amp;#8217;d like to be able to test deployment, but every deployment is a commit, and I like to commit &lt;em&gt;tested&lt;/em&gt; work.  I think I could use &lt;tt class="docutils literal"&gt;git rebase&lt;/tt&gt; but I lack the discipline to undo my work so I can do it correctly.  This is why I don&amp;#8217;t do continuous&amp;nbsp;commits.&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s a whole different level of weirdness when you use &lt;a class="reference external" href="http://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; as you aren&amp;#8217;t pushing to a deployment-specific remote, you are pushing to a deployment-specific&amp;nbsp;branch.&lt;/p&gt;
&lt;p&gt;So I&amp;#8217;ve generally thought: git deployment is&amp;nbsp;wrong.&lt;/p&gt;
&lt;p&gt;Then I was talking to some other people at Mozilla and they mentioned that ops was using git for simply moving files around even though the stuff they were deploying was itself in Mercurial.  They had a particular site with a very large number of files, and it was faster to use git than rsync (git has more metadata than rsync; rsync has to look at &lt;em&gt;everything&lt;/em&gt; everytime you sync).  And that all seemed very reasonable; git is a fine way to sync&amp;nbsp;things.&lt;/p&gt;
&lt;p&gt;But I kind of forgot about it all, and just swore to myself as I did too many trivial commits and wrote too many meaningless commit&amp;nbsp;messages.&lt;/p&gt;
&lt;p&gt;Still&amp;#8230; it isn&amp;#8217;t so hard to separate these concerns, is it?  So I wrote up a &lt;a class="reference external" href="https://github.com/ianb/git-sync/blob/master/git-sync"&gt;quite small command&lt;/a&gt; called &lt;a class="reference external" href="https://github.com/ianb/git-sync"&gt;git-sync&lt;/a&gt;.  The basic idea: copy the working directory to a new location (minus &lt;tt class="docutils literal"&gt;.git/&lt;/tt&gt;), commit that, and push the result to your deployment remote.  You can send modified and untracked files, and you can run a build script before committing and push the &lt;em&gt;result&lt;/em&gt; of the build script, all without sullying your &amp;#8220;real&amp;#8221; source control.  And you happen to have a nice history of deployments, which is also&amp;nbsp;nice.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve only used this a little bit, but I&amp;#8217;ve enjoyed when I have used it, and it makes me feel much better/clearer about my actual commits.  It&amp;#8217;s really short right now, and probably gets some things entirely wrong (e.g., moving over untracked files).  But it works well enough to be improved (&lt;em&gt;winkwinknudgenudge&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;So check it out: &lt;a class="reference external" href="https://github.com/ianb/git-sync"&gt;https://github.com/ianb/git-sync&lt;/a&gt;&lt;/p&gt;
</content><category term="misc"></category><category term="Programming"></category><category term="Web"></category></entry><entry><title>My Unsolicited Advice For PyPy</title><link href="https://www.ianbicking.org/blog/2011/04/my-unsolicited-advice-for-pypy.html" rel="alternate"></link><published>2011-04-04T09:23:00-05:00</published><updated>2011-04-04T09:23:00-05:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2011-04-04:/blog/2011/04/my-unsolicited-advice-for-pypy.html</id><summary type="html">&lt;p&gt;I think the most interesting work in programming languages right now is about the &lt;em&gt;runtime&lt;/em&gt;, not syntax or even the languages themselves. Which places PyPy in an interesting position, as they have put a great deal of effort into abstracting out the concept of runtime from the language they are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I think the most interesting work in programming languages right now is about the &lt;em&gt;runtime&lt;/em&gt;, not syntax or even the languages themselves. Which places PyPy in an interesting position, as they have put a great deal of effort into abstracting out the concept of runtime from the language they are implementing&amp;nbsp;(Python).&lt;/p&gt;
&lt;p&gt;There are of course other runtime environments available to Python. The main environment has and continues to be CPython &amp;#8212; the runtime developed in parallel with the language, and with continuous incremental feedback and improvement by the Python developer community.  It is the runtime that informs and is informed by the language.  It&amp;#8217;s also the runtime that is most easy-going about integrating with C libraries, and by extension it is part of the vague but important runtime environment of &amp;#8220;Unix&amp;#8221;.  There&amp;#8217;s also Jython and IronPython.  I frankly find these completely uninteresting.  They are runtimes controlled by companies, not communities, and the Python implementations are neither natural parts of their runtime environments, nor do the runtimes include many concessions to make themselves natural for&amp;nbsp;Python.&lt;/p&gt;
&lt;p&gt;PyPy is somewhere different.  It still has a tremendous challenge because Python was not developed &lt;em&gt;for&lt;/em&gt; PyPy.  Even small changes to the language seem impossible &amp;#8212; something as seemingly innocuous as making builtins static seems to be stuck in a conservative reluctance to change.  But unlike Jython and IronPython they aren&amp;#8217;t stuck between a rock and a hard place; they just have to deal with the rock, not the hard&amp;nbsp;place.&lt;/p&gt;
&lt;p&gt;So here is my unsolicited advice on what PyPy-the-runtime should consider.  Simple improvements to performance and the runtime are fine, but being incrementally better than CPython only goes so far, and I personally doubt it will ever make a big impact on Python that&amp;nbsp;way.&lt;/p&gt;
&lt;p&gt;PyPy should push hard on &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;reliability&lt;/em&gt;.  If it is &lt;em&gt;fast enough&lt;/em&gt; then that&amp;#8217;s fine; that&amp;#8217;s done as far as I&amp;#8217;m concerned. I say this because I&amp;#8217;m a web programmer, and speed is uninteresting to me.  Certainly opinions will differ.  But to me speed (as it&amp;#8217;s normally defined) is really &lt;em&gt;really&lt;/em&gt; uninteresting.  When or if I care about speed I&amp;#8217;m probably more drawn to Cython.  I &lt;em&gt;do&lt;/em&gt; care about latency, memory efficiency, scalability/concurrency, resource efficiency, and most of all &lt;em&gt;worst cases&lt;/em&gt;.  I don&amp;#8217;t think a &lt;span class="caps"&gt;JIT&lt;/span&gt; addresses any of these (and can even make things worse).  I don&amp;#8217;t know of benchmarks that measure these parameters&amp;nbsp;either.&lt;/p&gt;
&lt;p&gt;I want a runtime with new and novel features; something that isn&amp;#8217;t just incrementally better than CPython.  This itself might seem controversial, as the only point to such novel features would be for people to implement at least some code intended for &lt;em&gt;only&lt;/em&gt; PyPy.  But if the features are good enough then I&amp;#8217;m okay with this &amp;#8212; and if I&amp;#8217;m not drawn to write something that will only work on PyPy, I probably won&amp;#8217;t be drawn to use PyPy &lt;em&gt;at all&lt;/em&gt;; natural conservatism and inertia will keep me (and most people) on CPython&amp;nbsp;indefinitely.&lt;/p&gt;
&lt;p&gt;What do I&amp;nbsp;want?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Microprocesses&lt;/strong&gt;.  Stackless and greenlets have given us micro-threads, but it&amp;#8217;s just not the same.  Which is not entirely a criticism &amp;#8212; it shows that unportable features &lt;em&gt;are&lt;/em&gt; interesting when they are good features.  But I want the next step, which is processes that don&amp;#8217;t share state.  (And implicitly I don&amp;#8217;t just want standard async techniques, which use explicit concurrency and shared&amp;nbsp;state.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared objects&lt;/strong&gt; across processes with &lt;strong&gt;copy-on-write&lt;/strong&gt;; then you can efficiently share objects (like modules!) across concurrent processes without the danger of shared state, but without the overhead of copying &lt;em&gt;everything&lt;/em&gt; you want to share.  Lack of this is hurting &lt;span class="caps"&gt;PHP&lt;/span&gt;, as you can&amp;#8217;t have a rich set of libraries and share-nothing without killing your&amp;nbsp;performance.&lt;/li&gt;
&lt;li&gt;I&amp;#8217;d rather see a break in compatibility for C extensions to support this new model, than to abandon what could be PyPy&amp;#8217;s best feature to support CPython&amp;#8217;s C extension ecosystem.  Being a web programmer I honestly don&amp;#8217;t need many C modules, so maybe I&amp;#8217;m biased.  But if the rest of the system is good enough then the C extensions will&amp;nbsp;come.&lt;/li&gt;
&lt;li&gt;Make sure resource sharing that happens outside of the Python environment is really solid.  C libraries are often going to be unfriendly towards microprocesses; make sure what &lt;em&gt;is&lt;/em&gt; exposed to the Python environment is solid.  That might even mean a dangerous process mode that can handle ctypes and &lt;span class="caps"&gt;FFI&lt;/span&gt; and where you carefully write Python code that has extra powers, so long as there&amp;#8217;s a strong wall between that code and &amp;#8220;general&amp;#8221; code that makes use of those&amp;nbsp;services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cython&lt;/strong&gt; &amp;#8212; it&amp;#8217;s doing a lot of good stuff, and has a much more conservative but also more predictable path to performance (through things like type annotation).  I think it&amp;#8217;s worth leaning on.  I also have something of a hunch that it could be a good way to do &lt;span class="caps"&gt;FFI&lt;/span&gt; in a safe manner, as Cython already supports multiple targets (Python 2 and 3) from the same codebase.  Could PyPy be another&amp;nbsp;target?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Runtime introspection of the runtime&lt;/strong&gt;.  We have great language introspection (probably much to the annoyance of PyPy developers who have to copy this) but currently runtime introspection is poor-to-nonexistant. What processes are running?  How much memory is each using?  Where? Are they holding on to resources?  Are they blocking on some non-Python library?  How much &lt;span class="caps"&gt;CPU&lt;/span&gt; have they been using?  Then I want to be able to kill processes, send them signals, adjust priorities,&amp;nbsp;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And I guess it doesn&amp;#8217;t have to be &amp;#8220;PyPy&amp;#8221;, but a new backend for PyPy to target; it doesn&amp;#8217;t have to be the &lt;em&gt;only&lt;/em&gt; path PyPy&amp;nbsp;pursues.&lt;/p&gt;
&lt;p&gt;With a runtime like this PyPy could be an absolutely rocking platform for web development.  Python could be as reliable as, oh&amp;#8230; &lt;a class="reference external" href="http://blog.ianbicking.org/2008/01/12/what-php-deployment-gets-right/"&gt;&lt;span class="caps"&gt;PHP&lt;/span&gt;&lt;/a&gt;? Sorry, I probably won&amp;#8217;t win arguments that way ;)  As good as Erlang! Maybe we could get the benefits of async without the pain of callbacks or Deferreds. And these are features people would &lt;em&gt;use&lt;/em&gt;.  Right now I&amp;#8217;m perceiving a problem where there&amp;#8217;s lots of people standing on the sidelines cheering you on but not actually &lt;em&gt;using&lt;/em&gt;&amp;nbsp;PyPy.&lt;/p&gt;
&lt;p&gt;So: I wouldn&amp;#8217;t tell anyone what to do, and if someone tries this out I&amp;#8217;ll probably only be on the sidelines cheering you on&amp;#8230; but I really think this could be&amp;nbsp;awesome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: there&amp;#8217;s some &lt;a class="reference external" href="http://news.ycombinator.com/item?id=2406920"&gt;interesting comments on Hacker News&lt;/a&gt; as&amp;nbsp;well.&lt;/p&gt;
</content><category term="misc"></category><category term="Programming"></category><category term="Python"></category></entry><entry><title>A Python Web Application Package and Format (we should make one)</title><link href="https://www.ianbicking.org/blog/2011/03/a-python-web-application-package-and-format-we-should-make-one.html" rel="alternate"></link><published>2011-03-31T10:01:00-05:00</published><updated>2011-03-31T10:01:00-05:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2011-03-31:/blog/2011/03/a-python-web-application-package-and-format-we-should-make-one.html</id><summary type="html">&lt;p&gt;At PyCon there was an open space about deployment, and the idea of drop-in applications (Java-&lt;span class="caps"&gt;WAR&lt;/span&gt;-style).&lt;/p&gt;
&lt;p&gt;I generally get pessimistic about 80% solutions, and dropping in a &lt;span class="caps"&gt;WAR&lt;/span&gt; file feels like an 80% solution to me. I&amp;#8217;ve used the Hudson/Jenkins installer (which I think is &lt;em&gt;specifically …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;At PyCon there was an open space about deployment, and the idea of drop-in applications (Java-&lt;span class="caps"&gt;WAR&lt;/span&gt;-style).&lt;/p&gt;
&lt;p&gt;I generally get pessimistic about 80% solutions, and dropping in a &lt;span class="caps"&gt;WAR&lt;/span&gt; file feels like an 80% solution to me. I&amp;#8217;ve used the Hudson/Jenkins installer (which I think is &lt;em&gt;specifically&lt;/em&gt; a project that got WARs on people&amp;#8217;s minds), and in a lot of ways that installer is nice, but it&amp;#8217;s also kind of wonky, it makes configuration unclear, it&amp;#8217;s not always clear when it installs or configures itself through the web, and when you have to do this at the system level, nor is it clear where it puts files and data, etc. So a great initial experience doesn&amp;#8217;t feel like a great ongoing experience to me &amp;#8212; and &lt;em&gt;it doesn&amp;#8217;t have to be that way&lt;/em&gt;. If those were &lt;em&gt;necessary&lt;/em&gt; compromises, sure, but they aren&amp;#8217;t. And because we &lt;em&gt;don&amp;#8217;t have&lt;/em&gt; &lt;span class="caps"&gt;WAR&lt;/span&gt; files, if we&amp;#8217;re proposing to make something new, then we have every opportunity to make things&amp;nbsp;better.&lt;/p&gt;
&lt;p&gt;So the question then is what we&amp;#8217;re trying to make. To me: we want applications that are easy to install, that are self-describing, self-configuring (or at least guide you through configuration), reliable with respect to their environment (not dependent on system tweaking), upgradable, and respectful of persistence (the data that outlives the application install). A lot of this can be done by the &amp;#8220;container&amp;#8221; (to use Java parlance; or &amp;#8220;environment&amp;#8221;) &amp;#8212; if you just have the app packaged in a nice way, the container (server environment, hosting service, etc) can handle all the system-specific things to make the application actually&amp;nbsp;work.&lt;/p&gt;
&lt;p&gt;At which point I am of course reminded of my &lt;a class="reference external" href="http://cloudsilverlining.org"&gt;Silver Lining&lt;/a&gt; project, which defines something very much like this. Silver Lining isn&amp;#8217;t &lt;em&gt;just&lt;/em&gt; an application format, and things aren&amp;#8217;t fully extracted along these lines, but it&amp;#8217;s pretty close and it addresses a lot of important issues in the lifecycle of an application. To be clear: Silver Lining is an application packaging format, a server configuration library, a cloud server management tool, a persistence management tool, and a tool to manage the application with respect to all these services over time. It is a bunch of things, maybe too many things, so it is not unreasonable to pick out a smaller subset to focus on. Maybe an easy place to start (and good for Silver Lining itself) would be to separate at least the application format (and tools to manage applications in that state, e.g., installing new libraries) from the tools that make use of such applications (deploy,&amp;nbsp;etc).&lt;/p&gt;
&lt;p&gt;Some opinions I have on this format, exemplified in Silver&amp;nbsp;Lining:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It&amp;#8217;s not zipped or a single file, unlike WARs. Uploading zip files is not a great &lt;span class="caps"&gt;API&lt;/span&gt;. Geez. I know there&amp;#8217;s this desire to &amp;#8220;just drop in a file&amp;#8221;; but there&amp;#8217;s no getting around the fact that &amp;#8220;dropping a file&amp;#8221; becomes a &lt;em&gt;deployment protocol&lt;/em&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;em&gt;it&amp;#8217;s an incredibly impoverished protocol&lt;/em&gt;. The format is also not subtly git-based (ala Heroku) because &lt;tt class="docutils literal"&gt;git push&lt;/tt&gt; is not a good deployment&amp;nbsp;protocol.&lt;/li&gt;
&lt;li&gt;But of course there isn&amp;#8217;t really any deployment protocol inferred by a format anyway, so maybe I&amp;#8217;m getting ahead of myself ;) I&amp;#8217;m saying a tool that deploys should take as an argument a directory, not a single file. (If the tool then zips it up and uploads it,&amp;nbsp;fine!)&lt;/li&gt;
&lt;li&gt;Configuration &amp;#8220;comes from the outside&amp;#8221;. That is, an application requests services, and the &lt;em&gt;container&lt;/em&gt; tells the application where those services are. For Silver Lining I&amp;#8217;ve used environmental variables. I think this one point is really important &amp;#8212; the container &lt;em&gt;tells&lt;/em&gt; the application. As a counter-example, an application that comes with a Puppet deployment recipe is essentially &lt;em&gt;telling&lt;/em&gt; the server how to arrange itself to suit the application. This will never be reliable or&amp;nbsp;simple!&lt;/li&gt;
&lt;li&gt;The application indicates what &amp;#8220;services&amp;#8221; it wants; for instance, it may want to have access to a MySQL database. The container then provides this to the application. In practice this means installing the actual packages, but also creating a database and setting up permissions appropriately. The alternative is never having &lt;em&gt;any&lt;/em&gt; dependencies, meaning you have to use SQLite databases or ad hoc structures, etc. But in fact installing databases really isn&amp;#8217;t that hard these&amp;nbsp;days.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;All&lt;/em&gt; persistence has to use a service of some kind. If you want to be able to write to files, you need to use a file service. This means the container is fully aware of everything the application is leaving behind. All the various paths an application should use are given in different environmental variables (many of which don&amp;#8217;t need to be invented anew, e.g., &lt;tt class="docutils literal"&gt;$&lt;span class="caps"&gt;TMPDIR&lt;/span&gt;&lt;/tt&gt;).&lt;/li&gt;
&lt;li&gt;It uses vendor libraries exclusively for Python libraries. That means the application bundles all the libraries it requires. Nothing ever gets installed at deploy-time. This is in contrast to using a &lt;tt class="docutils literal"&gt;requirements.txt&lt;/tt&gt; list of packages at deployment time. If you want to use those tools for development that&amp;#8217;s fine, just not for&amp;nbsp;deployment.&lt;/li&gt;
&lt;li&gt;There &lt;em&gt;is&lt;/em&gt; also a way to indicate other libraries you might require; e.g., you might &lt;tt class="docutils literal"&gt;lxml&lt;/tt&gt;, or even something that isn&amp;#8217;t quite a library, like &lt;tt class="docutils literal"&gt;git&lt;/tt&gt; (if you are making a github clone). You can&amp;#8217;t do those as vendor libraries (they include non-portable binaries). Currently in Silver Lining the application description can contain a list of Ubuntu package names to install. Of course that would have to be abstracted&amp;nbsp;some.&lt;/li&gt;
&lt;li&gt;You can ask for scripts or a request to be invoked for an application after an installation or deployment. It&amp;#8217;s lame to try to test if is-this-app-installed on &lt;em&gt;every&lt;/em&gt; request, which is the frequent alternative. Also, it gives the application the chance to signal that the installation&amp;nbsp;failed.&lt;/li&gt;
&lt;li&gt;It has a very simple (possibly/probably too simple) sense of configuration. You don&amp;#8217;t have to use this if you make your app self-configuring (i.e., build in a web-accessible settings screen), but in practice it felt like some simple sense of configuration would be&amp;nbsp;helpful.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Things that could be&amp;nbsp;improved:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;There are some places where you might be encouraged to use routines from the &lt;tt class="docutils literal"&gt;silversupport&lt;/tt&gt; package. There are very few! But maybe an alternative could be provided for these&amp;nbsp;cases.&lt;/li&gt;
&lt;li&gt;A little convention-over-configuration is probably suitable for the bundled libraries; silver includes tools to manage things, but it gets a little twisty. When creating a new project I find myself creating several &lt;tt class="docutils literal"&gt;.pth&lt;/tt&gt; files, special customizing modules, etc. Managing vendor libraries is also not&amp;nbsp;obvious.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cloudsilverlining.org/services.html"&gt;Services&lt;/a&gt; are &lt;span class="caps"&gt;IMHO&lt;/span&gt; quite important and useful, but also need to be carefully&amp;nbsp;specified.&lt;/li&gt;
&lt;li&gt;There&amp;#8217;s a bunch of runtime expectations that aren&amp;#8217;t part of the format, but in practice would be part of how the application is written. For instance, I make sure each app has its own temporary directory, and that it is cleared on update. If you keep session files in that location, and you expect the environment to clean up old sessions &amp;#8212; well, either all environments should do that, or none&amp;nbsp;should.&lt;/li&gt;
&lt;li&gt;The process model is not entirely clear. I tried to simply define one process model (unthreaded, multiple processes), but I&amp;#8217;m not sure that&amp;#8217;s suitable &amp;#8212; most notably, multiple processes have a significant memory impact compared to threads. An application should at least be able to indicate what process models it accepts and&amp;nbsp;prefers.&lt;/li&gt;
&lt;li&gt;Static files are &lt;em&gt;all&lt;/em&gt; convention over configuration &amp;#8212; you put static files under &lt;tt class="docutils literal"&gt;static/&lt;/tt&gt; and then they are available. So &lt;tt class="docutils literal"&gt;static/style.css&lt;/tt&gt; would be at &lt;tt class="docutils literal"&gt;/style.css&lt;/tt&gt;. I think this is generally &lt;em&gt;good&lt;/em&gt;, but putting all static files under one &lt;span class="caps"&gt;URL&lt;/span&gt; path (e.g., &lt;tt class="docutils literal"&gt;/media/&lt;/tt&gt;) can be good for other reasons as well. Maybe there should be conventions for&amp;nbsp;both.&lt;/li&gt;
&lt;li&gt;Cron jobs are important. Though maybe they could just be yet another kind of service? Many extra features could be new&amp;nbsp;services.&lt;/li&gt;
&lt;li&gt;Logging is also important; Silver Lining attempts to handle that somewhat, but it could be specified much&amp;nbsp;better.&lt;/li&gt;
&lt;li&gt;Silver Lining also supports &lt;span class="caps"&gt;PHP&lt;/span&gt;, which seemed to cause a bit of stress. But just ignore that. It&amp;#8217;s really easy to&amp;nbsp;ignore.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is a &lt;a class="reference external" href="http://cloudsilverlining.org/appconfig.html"&gt;description of the configuration file for apps&lt;/a&gt;. The &lt;a class="reference external" href="http://cloudsilverlining.org/envvariables.html"&gt;environmental variables&lt;/a&gt; are also notably part of the application&amp;#8217;s expectations. The file layout is explained (together with a bunch of Silver Lining-specific concepts) in &lt;a class="reference external" href="http://cloudsilverlining.org/devpatterns.html"&gt;Development Patterns&lt;/a&gt;. Besides all that there is admittedly some other stuff that is only really specified in code; but in Silver Lining&amp;#8217;s defense, specified in code is better than unspecified ;) App Engine provides another example of an application format, and would be worth using as a point of discussion or contrast (I did that myself when writing Silver&amp;nbsp;Lining).&lt;/p&gt;
&lt;p&gt;Discussing &lt;span class="caps"&gt;WSGI&lt;/span&gt; stuff with Ben Bangert at PyCon he noted that he didn&amp;#8217;t really feel like the &lt;span class="caps"&gt;WSGI&lt;/span&gt; pieces needed that much more work, or at least that&amp;#8217;s not where the interesting work was &amp;#8212; the interesting work is in the tooling. An application format could provide a great basis for building this tooling. And I honestly think that the tooling has been held back more by divergent patterns of development than by the difficulty of writing the tools themselves; and a good, general application format could fix&amp;nbsp;that.&lt;/p&gt;
</content><category term="misc"></category><category term="Packaging"></category><category term="Programming"></category><category term="Python"></category><category term="Web"></category></entry><entry><title>Javascript on the server AND the client is not a big deal</title><link href="https://www.ianbicking.org/blog/2011/03/javascript-on-the-server-and-the-client-is-not-a-big-deal.html" rel="alternate"></link><published>2011-03-30T16:09:00-05:00</published><updated>2011-03-30T16:09:00-05:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2011-03-30:/blog/2011/03/javascript-on-the-server-and-the-client-is-not-a-big-deal.html</id><summary type="html">&lt;p&gt;All the cool kids love &lt;a class="reference external" href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;.  I&amp;#8217;ve used it a little, and it&amp;#8217;s fine; I was able to do what I wanted to do, and it wasn&amp;#8217;t particularly painful.  It&amp;#8217;s fun to use something new, and it&amp;#8217;s relatively straight-forward to get started so it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;All the cool kids love &lt;a class="reference external" href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;.  I&amp;#8217;ve used it a little, and it&amp;#8217;s fine; I was able to do what I wanted to do, and it wasn&amp;#8217;t particularly painful.  It&amp;#8217;s fun to use something new, and it&amp;#8217;s relatively straight-forward to get started so it&amp;#8217;s an &lt;em&gt;emotionally satisfying&lt;/em&gt;&amp;nbsp;experience.&lt;/p&gt;
&lt;p&gt;There are several reasons you might want to use Node.js, and I&amp;#8217;ll ignore many of them, but I want to talk about one in&amp;nbsp;particular:&lt;/p&gt;
&lt;blockquote&gt;
Javascript on the client and the server!&lt;/blockquote&gt;
&lt;p&gt;Is this such a great feature?  I think&amp;nbsp;not&amp;#8230;&lt;/p&gt;
&lt;div class="section" id="you-only-need-to-know-one-language"&gt;
&lt;h2&gt;You only need to know one&amp;nbsp;language!&lt;/h2&gt;
&lt;p&gt;Sure.  Yay ignorance!  But really, this is &lt;em&gt;fine&lt;/em&gt; but unlikely to be relevant to any current potential audience for Node.js.  If you are shooting for an very-easy-to-learn client-server programming system, Node.js isn&amp;#8217;t it.  Maybe &lt;a class="reference external" href="http://couchapp.org/"&gt;Couch&lt;/a&gt; or something similar has that potential?  But I&amp;nbsp;digress.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s not easy to have expertise at multiple languages.  But it&amp;#8217;s not &lt;em&gt;that hard&lt;/em&gt;.  It&amp;#8217;s considerably harder to have expertise at &lt;em&gt;multiple platforms&lt;/em&gt;.  Node.js gives you one language across client and server, but &lt;em&gt;not&lt;/em&gt; one platform.  Node.js programming doesn&amp;#8217;t &lt;em&gt;feel&lt;/em&gt; like the browser environment.  They do adopt many conventions when it&amp;#8217;s reasonable, but even then it&amp;#8217;s not always the case &amp;#8212; in particular because many browser APIs are the awkward product of C++ programmers exposing things to Javascript, and you don&amp;#8217;t want to reproduce those same APIs if you don&amp;#8217;t have to (and Node.js doesn&amp;#8217;t have to!) &amp;#8212; an example is the event pattern in Node, which is similar to a browser but less&amp;nbsp;obtuse.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="you-get-to-share-libraries"&gt;
&lt;h2&gt;You get to share&amp;nbsp;libraries!&lt;/h2&gt;
&lt;p&gt;First: the same set of libraries is probably not applicable.  If you can do it on the client then you probably don&amp;#8217;t &lt;em&gt;have&lt;/em&gt; to do it on the server, and vice&amp;nbsp;versa.&lt;/p&gt;
&lt;p&gt;But sometimes the same libraries are useful.  Can you really share them?  Browser libraries are often hard to use elsewhere because they rely on browser APIs.  These APIs are frequently &lt;em&gt;impossible to implement in Javascript&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Actually they are possible to implement in Javascript using &lt;a class="reference external" href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Proxy"&gt;Proxies&lt;/a&gt; (or maybe some other new and not-yet-standard Javascript features). But not in Node.js, which uses V8, and V8 is a pretty conservative implementation of the Javascript language. (&lt;strong&gt;Update&lt;/strong&gt;: &lt;a class="reference external" href="http://blog.ianbicking.org/2011/03/30/js-on-server-and-client-is-not-a-big-deal/comment-page-1/#comment-194005"&gt;it is noted&lt;/a&gt; that you can &lt;a class="reference external" href="https://github.com/isaacs/node-proxy/tree/master/src"&gt;implement proxies&lt;/a&gt; &amp;#8212; in this case a C++ extension to&amp;nbsp;Node)&lt;/p&gt;
&lt;p&gt;Besides these unimplementable APIs, it is also just a different environment.  There is the trivial: the &lt;tt class="docutils literal"&gt;window&lt;/tt&gt; object in the browser has a Node.js equivalent, but it&amp;#8217;s not named &lt;tt class="docutils literal"&gt;window&lt;/tt&gt;. Performance is different &amp;#8212; Node has long-running processes, the browser &lt;em&gt;might&lt;/em&gt;.  Node can have blocking calls, which are useful even if you can&amp;#8217;t use them at runtime (e.g., &lt;tt class="docutils literal"&gt;require()&lt;/tt&gt;); but you can&amp;#8217;t really have any of these at any time on the browser.  And then of course all the system calls, &lt;em&gt;none&lt;/em&gt; of which you can use in the&amp;nbsp;browser.&lt;/p&gt;
&lt;p&gt;All these may simply be surmountable challenges, through modularity, mocking, abstractions, and so on&amp;#8230; but ultimately I think the motivation is lacking: the domain of changing a live-rendered &lt;span class="caps"&gt;DOM&lt;/span&gt; isn&amp;#8217;t the same as producing bytes to put onto a&amp;nbsp;socket.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="you-can-work-fluidly-across-client-and-server"&gt;
&lt;h2&gt;You can work fluidly across client and&amp;nbsp;server!&lt;/h2&gt;
&lt;p&gt;If anything I think this is &lt;em&gt;dangerous&lt;/em&gt; rather than &lt;em&gt;useful&lt;/em&gt;.  The client and the server are different places, with different expectations.  Any vagueness about that boundary is &lt;em&gt;wrong&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s wrong from a security perspective, as the security assumptions are nearly opposite on the two platforms.  The client trusts itself, and the server trusts itself, and both should hold the other in suspicion (though the client can be more trusting because the &lt;em&gt;browser&lt;/em&gt; doesn&amp;#8217;t trust the client&amp;nbsp;code).&lt;/p&gt;
&lt;p&gt;But it&amp;#8217;s also the wrong way to treat &lt;span class="caps"&gt;HTTP&lt;/span&gt;.  &lt;span class="caps"&gt;HTTP&lt;/span&gt; is pretty simple until you try to make it simpler.  Efforts to make it simpler mostly make it more complicated.  &lt;span class="caps"&gt;HTTP&lt;/span&gt; lets you send serialized data back and forth to a server, with a bunch of metadata and other do-dads.  And that&amp;#8217;s all neat, but you should always be thinking about &lt;em&gt;sending&lt;/em&gt; information.  And never &lt;em&gt;sharing&lt;/em&gt; information.  It&amp;#8217;s not a fluid boundary, and code that touches &lt;span class="caps"&gt;HTTP&lt;/span&gt; needs to be explicit about it and not pretend it is equivalent to any other non-network&amp;nbsp;operation.&lt;/p&gt;
&lt;p&gt;Certainly you don&amp;#8217;t &lt;em&gt;need&lt;/em&gt; two implementation languages to keep your mind clear.  But it doesn&amp;#8217;t&amp;nbsp;hurt.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="you-can-do-validation-the-same-way-on-the-client-and-server"&gt;
&lt;h2&gt;You can do validation the same way on the client and&amp;nbsp;server!&lt;/h2&gt;
&lt;p&gt;One of the things people frequently bring up is that you can validate data on the client and server using the same code.  And of course, what web developer hasn&amp;#8217;t been a little frustrated that they have to implement validation&amp;nbsp;twice?&lt;/p&gt;
&lt;p&gt;Validation on the client is primarily a &lt;em&gt;user experience&lt;/em&gt; concern, where you focus on bringing attention to problems with a form, and helping the user resolve those problems.  You may be able to avoid errors entirely with an input method that avoids the problem (e.g., if a you have a slider for a numeric input, you don&amp;#8217;t have to worry about the user inputing a non-numeric&amp;nbsp;value).&lt;/p&gt;
&lt;p&gt;Once the form is submitted, if you&amp;#8217;ve done thorough client-side validation you can also avoid &lt;em&gt;friendly&lt;/em&gt; server-side validation.  Of course all your client-side validation could be avoided through a malicious client, but you don&amp;#8217;t need to give a friendly error message in that case, you can simply bail out with a simple 400 Bad Request&amp;nbsp;error.&lt;/p&gt;
&lt;p&gt;At that point there&amp;#8217;s not much in common between these two kinds of validation &amp;#8212; the client is all user experience, and the server is all data&amp;nbsp;integrity.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="you-can-do-server-side-javascript-as-a-fallback-for-the-client"&gt;
&lt;h2&gt;You can do server-side Javascript as a fallback for the&amp;nbsp;client!&lt;/h2&gt;
&lt;p&gt;Writing for clients without Javascript is becoming increasingly less relevant, and if we aren&amp;#8217;t &lt;em&gt;there&lt;/em&gt; yet, then we&amp;#8217;ll certainly &lt;em&gt;get there&lt;/em&gt; soon.  It&amp;#8217;s only a matter of time, the writing is on the wall. Depending on the project you might have to put in workarounds, but we should keep those concerns out of architecture decisions.  Maintaining crazy hacks is &lt;em&gt;not&lt;/em&gt; worth it. There&amp;#8217;s so many terrible hacks that have turned into frameworks, and frameworks that have justified themselves because of the problems they solved that no longer matter&amp;#8230; Node.js deserves better than to be one of&amp;nbsp;those.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="in-conclusion-or-whatever"&gt;
&lt;h2&gt;In Conclusion Or&amp;nbsp;Whatever&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m not saying Node.js is &lt;em&gt;bad&lt;/em&gt;.  There are other arguments for it, and you don&amp;#8217;t need to make &lt;em&gt;any&lt;/em&gt; argument for it if you just feel like using it.  It&amp;#8217;s fun to do something new.  And I&amp;#8217;m as optimistic about Javascript as anyone.  But this one argument, I do not think it is very&amp;nbsp;good.&lt;/p&gt;
&lt;/div&gt;
</content><category term="misc"></category><category term="Javascript"></category><category term="Programming"></category><category term="Web"></category></entry><entry><title>About</title><link href="https://www.ianbicking.org/blog/2007/07/about.html" rel="alternate"></link><published>2007-07-31T15:53:00-05:00</published><updated>2007-07-31T15:53:00-05:00</updated><author><name>Admin</name></author><id>tag:www.ianbicking.org,2007-07-31:/blog/2007/07/about.html</id><summary type="html">&lt;p&gt;Hi, I&amp;#8217;m &lt;a class="reference external" href="http://ianbicking.org"&gt;Ian Bicking&lt;/a&gt;.  I work at &lt;a class="reference external" href="http://topp.openplans.org"&gt;The Open Planning Project&lt;/a&gt;.  I do lots of programming in Python.  I keep a &lt;a class="reference external" href="http://ianbicking.org/cv.html#open-source-projects"&gt;list of projects I participate in&lt;/a&gt;, though I don&amp;#8217;t always update it.  Lots of stuff in &lt;a class="reference external" href="http://svn.colorstudy.com"&gt;svn.colorstudy.com&lt;/a&gt; and &lt;a class="reference external" href="http://svn.pythonpaste.org"&gt;svn.pythonpaste.org&lt;/a&gt; is written by&amp;nbsp;me …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Hi, I&amp;#8217;m &lt;a class="reference external" href="http://ianbicking.org"&gt;Ian Bicking&lt;/a&gt;.  I work at &lt;a class="reference external" href="http://topp.openplans.org"&gt;The Open Planning Project&lt;/a&gt;.  I do lots of programming in Python.  I keep a &lt;a class="reference external" href="http://ianbicking.org/cv.html#open-source-projects"&gt;list of projects I participate in&lt;/a&gt;, though I don&amp;#8217;t always update it.  Lots of stuff in &lt;a class="reference external" href="http://svn.colorstudy.com"&gt;svn.colorstudy.com&lt;/a&gt; and &lt;a class="reference external" href="http://svn.pythonpaste.org"&gt;svn.pythonpaste.org&lt;/a&gt; is written by&amp;nbsp;me.&lt;/p&gt;
</content><category term="misc"></category><category term="Programming"></category></entry></feed>