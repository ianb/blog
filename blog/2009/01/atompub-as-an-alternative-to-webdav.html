<!DOCTYPE html>
<html lang="en">
<head>
        <title>Atompub as an alternative to WebDAV</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
          <link rel="stylesheet" href="https://ianbicking.org/theme/css/style.min.css">
        <!--<link rel="stylesheet" href="https://ianbicking.org/theme/css/main.css" type="text/css" />-->
        <link href="https://ianbicking.org/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Ian Bicking: a blog Atom Feed" />
        <link rel="icon" href="https://ianbicking.org/favicon.ico">

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://ianbicking.org/css/ie.css"/>
                <script src="https://ianbicking.org/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="https://ianbicking.org/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
  <div id="main-wrapper1">
  <div id="main-wrapper2">
  <div id="main-container">
        <header id="banner" class="body">
                <h1><a href="https://ianbicking.org">Ian Bicking: a blog </a></h1>
        </header><!-- /#banner -->
<section id="content" class="body">
    <article>
        <header>
            <abbr class="published" title="2009-01-11T17:27:00-06:00">
                Sunday, January 11st, 2009
            </abbr>
            <h1 class="entry-title">
                <a
                    href="https://ianbicking.org/blog/2009/01/atompub-as-an-alternative-to-webdav.html"
                    rel="bookmark"
                    title="Permalink to Atompub as an alternative to WebDAV"
                    >Atompub as an alternative to&nbsp;WebDAV</a
                >
            </h1>
        </header>

        <div class="entry-content"><p>I&#8217;ve been thinking about an import/export <span class="caps">API</span> for <a class="reference external" href="http://pickywiki.org">PickyWiki</a>; I want something that&#8217;s sensible, and works well enough that it can be the basic for things like creating restorable snapshots, integration with version control systems, and being good at self-hosting&nbsp;documentation.</p>
<p>So far I&#8217;ve made a simple import/export system based on Atom.  You can export the entire site as an Atom feed, and you can import Atom feeds.  But whole-site import/export isn&#8217;t enough for the tools I&#8217;d like to write on top of the <span class="caps">API</span>.</p>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/WebDAV">WebDAV</a> would seem like a logical choice, as it lets you get and put resources.   But it&#8217;s not a great choice for a few&nbsp;reasons:</p>
<ul class="simple">
<li>It&#8217;s really hard to implement on the&nbsp;server.</li>
<li>Even clients are hard to&nbsp;implement.</li>
<li>It uses <span class="caps">GET</span> to get resources.  This is probably its most fatal flaw.  There is no <span class="caps">CMS</span> that I know of (except <a class="reference external" href="http://www.tiddlywiki.com/">maybe one</a>) where the thing you view the browser is the thing that you&#8217;d actually edit.  To work around this CMSes use User-Agent sniffing or an alternate <span class="caps">URL</span>&nbsp;space.</li>
<li>WebDAV is worried about &#8220;collections&#8221; (i.e., directories).  The web basically doesn&#8217;t know what &#8220;collections&#8221; are, it only knows paths, and paths are&nbsp;strings.</li>
<li>(In summary) WebDAV uses <span class="caps">HTTP</span>, but it is not <em>of the web</em>.</li>
</ul>
<p>I don&#8217;t want to invent something new though.  So I started thinking of Atom some more, and <a class="reference external" href="http://en.wikipedia.org/wiki/Atom_(standard)">Atompub</a>.</p>
<p>The first thought is how to fix the <span class="caps">GET</span> problem in WebDAV.  A web page isn&#8217;t an editable representation, but it&#8217;s pretty reasonable to put an editable representation into an Atom entry.  Clients won&#8217;t necessarily understand extensions and properties you might add to those entries, but I don&#8217;t see any way around that.  An entry might look&nbsp;like:</p>
<pre class="literal-block">
&lt;entry&gt;
  &lt;content type=&quot;html&quot;&gt;QUOTED HTML&lt;/content&gt;
  ... other normal metadata (title etc) ...
  &lt;privateprop:myproperty xmlns:privateprop=&quot;URL&quot; name=&quot;foo&quot; value=&quot;bar&quot;  /&gt;
&lt;/entry&gt;
</pre>
<p>While there is special support for <span class="caps">HTML</span>, <span class="caps">XHTML</span>, and plain text in Atom, you can put any type of content in <tt class="docutils literal">&lt;content&gt;</tt>, encoded in&nbsp;base64.</p>
<p>To find the editable representation, the browser page can point to it.  I imagine something like&nbsp;this:</p>
<pre class="literal-block">
&lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml; type=entry&quot;
 href=&quot;this-url?format=atom&quot;&gt;
</pre>
<p>The actual <span class="caps">URL</span> (in this example <tt class="docutils literal"><span class="pre">this-url?format=atom</span></tt>) can be pretty much anything.  My one worry is that this could be confused with feed detection, which looks&nbsp;like:</p>
<pre class="literal-block">
&lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot;
 href=&quot;/atom.xml&quot;&gt;
</pre>
<p>The only difference is &#8220;; type=entry&#8221;, which I&#8217;m betting a lot of clients don&#8217;t pay attention&nbsp;to.</p>
<p>The Atom entries then can have an&nbsp;element:</p>
<pre class="literal-block">
&lt;link rel=&quot;edit&quot; href=&quot;this-url&quot;  /&gt;
</pre>
<p>This is a location where you can <span class="caps">PUT</span> a new entry to update the resource.  You could allow the client to <span class="caps">PUT</span> directly over the old page, or use <tt class="docutils literal"><span class="pre">this-url?format=atom</span></tt> or whatever is convenient on the server-side.  Additionally, <span class="caps">DELETE</span> to the same <span class="caps">URL</span> would&nbsp;delete.</p>
<p>This handles updates and deletes, and single-page reads.  The next issue is creating&nbsp;pages.</p>
<p>Atompub makes creation fairly simple.  First you have to get the <a class="reference external" href="http://bitworking.org/projects/atom/rfc5023.html#appdocs">Atompub service document</a>.  This is a document with the type <tt class="docutils literal">application/atomsvc+xml</tt> and it gives the collection <span class="caps">URL</span>.  <a class="reference external" href="http://wiki.whatwg.org/wiki/ServiceRelExtension">It&#8217;s suggested</a> you make this document discoverable&nbsp;like:</p>
<pre class="literal-block">
&lt;link rel=&quot;service&quot; type=&quot;application/atomsvc+xml&quot;
 href=&quot;/atomsvc.xml&quot;&gt;
</pre>
<p>This document then points to the &#8220;collection&#8221; <span class="caps">URL</span>, which for our purposes is where you create documents.  The service document would look&nbsp;like:</p>
<pre class="literal-block">
&lt;service xmlns=&quot;http://www.w3.org/2007/app&quot;
         xmlns:atom=&quot;http://www.w3.org/2005/Atom&quot;&gt;
  &lt;workspace&gt;
    &lt;atom:title&gt;SITE TITLE&lt;/atom:title&gt;
    &lt;collection href=&quot;/atomapi&quot;&gt;
      &lt;atom:title&gt;SITE TITLE&lt;/atom:title&gt;
      &lt;accept&gt;*/*&lt;/accept&gt;
      &lt;accept&gt;application/atom+xml;type=entry&lt;/accept&gt;
    &lt;/collection&gt;
  &lt;/workspace&gt;
&lt;/service&gt;
</pre>
<p>Basically this indicates that you can <span class="caps">POST</span> any media to <tt class="docutils literal">/atomapi</tt> (both Atom entries, and things like&nbsp;images).</p>
<p>To create a page, a client then does a <span class="caps">POST</span>&nbsp;like:</p>
<pre class="literal-block">
POST /atomapi
Content-Type: application/atom+xml; type=entry
Slug: /page/path

&lt;entry xmlns=&quot;...&quot;&gt;...&lt;/entry&gt;
</pre>
<p>There&#8217;s an awkwardness here, that you can suggest (via the Slug header) what the <span class="caps">URL</span> for the new page is.  The client can find the actual <span class="caps">URL</span> of the new page from the Location header in the response. But the client can&#8217;t demand that the slug be respected (getting an error back if it is not), and there&#8217;s lots of use cases where the client doesn&#8217;t just want to <em>suggest</em> a path (for instance, other documents that are being created might rely on that path for&nbsp;links).</p>
<p>Also, &#8220;slug&#8221; implies&#8230; well, a slug.  That is, some path segment probably derived from the title.  There&#8217;s nothing stopping the client from putting a complete path in there, but it&#8217;s very likely to be misinterpreted (e.g. translating <tt class="docutils literal">/page/path</tt> to <tt class="docutils literal">/2009/01/pagepath</tt>).</p>
<p>Bug I digress.  Anyway, you can post every resource as an entry, base64-encoding the resource body, but Atompub also allows POSTing media directly.  When you do that, the server puts the media somewhere and creates a simple Atom entry for the media.  If you wanted to add properties to that entry, you&#8217;d edit the entry after creating&nbsp;it.</p>
<p>The last missing piece is how to get a list of all the pages on a site.  Atompub <em>does</em> have an answer for this: just <tt class="docutils literal"><span class="caps">GET</span> /atomapi</tt> will give you an Atom feed, and for our purposes we can demand that the feed is complete (using paging so that any one page of the feed doesn&#8217;t get too big).  But this doesn&#8217;t seem like a good solution to me.  <a class="reference external" href="http://code.google.com/apis/gdata/overview.html">GData</a> specifies a useful set of queries to for feeds, but I&#8217;m not sure that this is very useful here; the kind of queries a client needs to do for this use case aren&#8217;t things GData was designed&nbsp;for.</p>
<p>The queries that seem most important to me are queries by page path (which allows some sense of &#8220;collections&#8221; without being formal) and by content type.  Also to allow incremental updates on the client side, filtering these queries by last-modified time (i.e., all pages created since I last looked).  Reporting queries (date of creation, update, author, last editor, and custom properties) of course <em>could</em> be useful, but don&#8217;t seem as directly&nbsp;applicable.</p>
<p>Also, often the client won&#8217;t want the complete Atom entry for the pages, but only a list of pages (maybe with minimal metadata).  I&#8217;m unsure about the validity of abbreviated Atom entries, but it seems like one solution.  Any Atom entry can have something&nbsp;like:</p>
<pre class="literal-block">
&lt;link rel=&quot;self&quot; type=&quot;application/atom+xml; type=entry&quot;
 href=&quot;url?format=atom&quot;  /&gt;
</pre>
<p>This indicates where the entry exists, though it doesn&#8217;t suggest very forcefully that the actual entry is abbreviated.  Anyway, I could then imagine a feed&nbsp;like:</p>
<pre class="literal-block">
&lt;feed&gt;
  &lt;entry&gt;
    &lt;title&gt;the page title&lt;/title&gt;
    &lt;content type=&quot;some/content-type&quot;  /&gt;
    &lt;link rel=&quot;self&quot; href=&quot;...&quot;  /&gt;
    &lt;updated&gt;YYYYMMDDTHH:MM:SSZ&lt;/updated&gt;
  &lt;entry&gt;
  ...
&lt;/feed&gt;
</pre>
<p>This isn&#8217;t entirely valid, however &#8212; you can&#8217;t just have an empty <tt class="docutils literal">&lt;content&gt;</tt> tag.  You can use a <tt class="docutils literal">src</tt> attribute to use indirection for the content, and then add Yet Another <span class="caps">URL</span> for each page that points to its raw content.  But that&#8217;s just jumping through hoops.  This also seems like an opportunity to suggest that the entry is&nbsp;incomplete.</p>
<p>To actually construct these feeds, you need some way of getting the feed.  I suggest that another entry be added to the Atompub service document, something&nbsp;like:</p>
<pre class="literal-block">
&lt;cmsapi:feed href=&quot;URI-TEMPLATE&quot;  /&gt;
</pre>
<p>That would be a <a class="reference external" href="http://bitworking.org/projects/URI-Templates/"><span class="caps">URI</span> Template</a> that accepted several known variables (though frustratingly, <span class="caps">URI</span> Templates aren&#8217;t properly standardized yet).  Things&nbsp;like:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">content-type</span></tt>: the content type of the resource (allowing wildcards like <tt class="docutils literal">image/*</tt>)</li>
<li><tt class="docutils literal">container</tt>: a path to a container, i.e., <tt class="docutils literal">/2007</tt> would match all pages in <tt class="docutils literal"><span class="pre">/2007/...</span></tt></li>
<li><tt class="docutils literal"><span class="pre">path-regex</span></tt>: some regular expression to match the&nbsp;paths</li>
<li><tt class="docutils literal"><span class="pre">last-modified</span></tt>: return all pages modified at the given date or&nbsp;later</li>
</ul>
<p>All parameters would be ANDed&nbsp;together.</p>
<p>So, open&nbsp;issues:</p>
<ul class="simple">
<li>How to strongly suggest a path when creating a resource (better than&nbsp;Slug)</li>
<li>How to rename (move) or copy a page (it&#8217;s easy enough to punt on copy, but I&#8217;d rather move by a <em>little</em> more formal than just recreating a resource in a new location and deleting the&nbsp;original)</li>
<li>How to represent abbreviated Atom&nbsp;entries</li>
</ul>
<p>With these resolved I think it&#8217;d be possible to create a much simpler <span class="caps">API</span> than WebDAV, and one that can be applied to existing applications much more easily.  (If you think there&#8217;s more missing, please&nbsp;comment.)</p>
</div>
        <!-- /.entry-content -->
    </article>
</section>
        <section id="extras" class="body">
                <div class="links">
                  <h2><a href="https://ianbicking.org">here</a></h2>
                  <ul>
                    <li><a href="/blog/">blog</a></li>
                    <li><a href="/projects.html">projects</a></li>
                    <li><a href="https://ianbicking.org/archives.html">archives</a> &amp; <a href="https://ianbicking.org/categories.html">categories</a></li>
                    <li><a href="https://ianbicking.org/category/javascript.html">category: javascript</a></li>
                    <li><a href="https://ianbicking.org/category/misc.html">category: misc</a></li>
                    <li><a href="https://ianbicking.org/category/mozilla.html">category: mozilla</a></li>
                    </ul>
                </div>
                <div class="social">
                        <h2>elsewhere</h2>
                        <ul>
                            <li><a href="https://ianbicking.org/feeds/atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://twitter.com/ianbicking">@ianbicking</a></li>
                            <li><a href="https://hachyderm.io/@ianbicking">@ianbicking@hachyderm.io</a></li>
                            <li><a href="https://github.com/ianb">Github</a></li>
                        </ul>
                </div><!-- /.social -->
                <div class="archives">
                  <h2><a href="https://ianbicking.org/blog/">recent posts</a></h2>
                  <ul>
                    <li><a href="https://ianbicking.org/blog/2020/11/firefox-was-always-enough.html">Firefox Was Always&nbsp;Enough</a></li>
                    <li><a href="https://ianbicking.org/blog/2020/09/project-ideas-2020.html">Project ideas for (what&#8217;s left of)&nbsp;2020</a></li>
                    <li><a href="https://ianbicking.org/blog/2020/09/a-history-of-projects.html">A History Of&nbsp;Projects</a></li>
                    <li><a href="https://ianbicking.org/blog/2020/08/thoughts-on-voice-interfaces.html">Thoughts on Voice&nbsp;Interfaces</a></li>
                    <li><a href="https://ianbicking.org/blog/2019/07/kling-axes-of-politics-technocrats.html">Kling&#8217;s Axes of Politics, and the&nbsp;Technocrats</a></li>
                    <li><a href="https://ianbicking.org/blog/2019/04/users-want-control-is-a-shrug.html"><span class="dquo">&#8220;</span>Users want control&#8221; is a shoulder&nbsp;shrug</a></li>
                    <li><a href="https://ianbicking.org/blog/2019/03/open-source-doesnt-make-money-by-design.html">Open Source Doesn&#8217;t Make Money Because It Isn&#8217;t Designed To Make&nbsp;Money</a></li>
                    <li><a href="https://ianbicking.org/blog/2019/03/firefox-experiments-i-would-have-liked.html">The Firefox Experiments I Would Have Liked To&nbsp;Try</a></li>
                    <li><a href="https://ianbicking.org/blog/2019/01/overengaged-knowledge-worker.html">The Over-engaged Knowledge&nbsp;Worker</a></li>
                    <li><a href="https://ianbicking.org/blog/2019/01/we-need-open-hosting-platforms.html">We Need Open Hosting&nbsp;Platforms</a></li>
                  </ul>
                </div><!-- /.archives -->

                <div class="widgets">
                  <h2><a href="https://twitter.com/ianbicking">tweets</a></h2>
                  <a class="twitter-timeline" width="230" height="500" href="https://twitter.com/ianbicking" data-widget-id="319849964417187842" data-link-color="#aaae94">Tweets by @ianbicking</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

                </div><!-- /.widgets -->

        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
          This is the personal site of <a href="/">Ian Bicking</a>.  The opinions expressed here are my own.
        </footer><!-- /#contentinfo -->

<script src="/theme/instantclick.min.js"></script>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-2442258-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
        </div><!-- /#main-container -->
        </div><!-- /#main-wrapper2 -->
        </div><!-- /#main-wrapper1 -->
</body>
</html>