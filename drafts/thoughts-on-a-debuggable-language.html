<!DOCTYPE html>
<html lang="en">
<head>
        <title>Thoughts on a debuggable programming language</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
          <link rel="stylesheet" href="https://ianbicking.org/theme/css/style.min.css">
        <!--<link rel="stylesheet" href="https://ianbicking.org/theme/css/main.css" type="text/css" />-->
        <link href="https://ianbicking.org/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Ian Bicking: a blog Atom Feed" />
        <link rel="icon" href="https://ianbicking.org/favicon.ico">

</head>

<body id="index" class="home">
  <div id="main-wrapper1">
  <div id="main-wrapper2">
  <div id="main-container">
        <header id="banner" class="body">
                <h1><a href="https://ianbicking.org">Ian Bicking: a blog </a></h1>
        </header><!-- /#banner -->
<section id="content" class="body">
    <article>
        <header>
        <div>
            <div class="published" title="2013-05-29T00:00:00-05:00">
                Wednesday, May 29th, 2013
            </div>
            <h1 class="entry-title">
                <a
                    href="https://ianbicking.org/drafts/thoughts-on-a-debuggable-language.html"
                    rel="bookmark"
                    title="Permalink to Thoughts on a debuggable programming language"
                    >Thoughts on a debuggable programming&nbsp;language</a
                >
            </h1>
        </div>
        </header>

        <div class="entry-content"><p>New programming languages are often designed to do some thing well. Sure, there&#8217;s general purpose languages, but there&#8217;s often some specific aspect that is being&nbsp;explored.</p>
<p>Examples might be concurrency, type safety, flexible or expressive syntax, adaptable runtime or just adapting to a specific&nbsp;runtime.</p>
<p>Along the way debuggability is usually a late afterthought.  The programming language author imagines primarily correct programs.  Or, maybe also imagines <em>specific</em> incorrect programs, such as a program with the incorrect use of types &#8212; and even then simple rejection of incorrect programs is considered sufficient.  But any program that doesn&#8217;t do what you want it to do isn&#8217;t a correct program.  If you extend your imagination a bit further, an empty file is itself the incorrect program that you must fix through&nbsp;composition.</p>
<p>And I&#8217;ve <a href="">gotten it in my head</a>: what if you designed a language for debuggability?  And, since we&#8217;re being ambitious, take a wide view of debugging.  A debugging session often means debugging your own conception of how the program should work, when that concept is incomplete or&nbsp;impossible.</p>
<p>If that is the goal, then the other features of the langauge &#8212; object model, syntax, process and concurrency model &#8212; should be deferred or use placeholder proposals so that they can be changed to serve the primary goal of the&nbsp;language.</p>
<p>This imaginary language isn&#8217;t as interesting as thinking about what it might actually look&nbsp;like.</p>
<h2>Locality, locality,&nbsp;locality</h2>
<p>Regardless of programming language, I find among the most important principals of flexible and understandable code is emphasizing locality of effect.  The ability to look at a piece of code and <em>know</em> what it depends on and what it affects.  And that depedendent pieces of code are located together.  One of the primary features I&#8217;d like to see is the ability to detect and make use of locality of&nbsp;effect.</p>
<p>To achieve locality I&#8217;d like to dive&nbsp;deeper&#8230;</p>
<h3>Modular&nbsp;execution</h3>
<p>In my head I can know a piece of code is localized, but seldom does that mean I can actually use it independently.  Or at least seldom is that true of the code I care about: the code that is hard to work with, the code that has bugs, the code that is difficult to extend. You can simply say &#8220;don&#8217;t write such code!&#8221; &#8212; but it doesn&#8217;t exist because I&#8217;m too lazy to fix it, it exists because some parts of a program are tricky that way.  But what might we do to make it possible to execute bits of code in isolation, even the hard&nbsp;bits?</p>
<p>The problem I see is that there&#8217;s generally a lot of <em>state</em> that must be set up just right before you can execute this more difficult code. There might be a lifecycle to the application.  There might be other services the application interacts with that have their own complicated state management.  And the code may run very differently depending on that initial state &#8212; every condition is a case where the path of execution branches based on&nbsp;state.</p>
<p>And so, to achieve modularity I&#8217;d like to dive&nbsp;deeper&#8230;</p>
<h4>Full introspection of a program&#8217;s&nbsp;state</h4>
<p>If we&#8217;re going to solve these problems of initial state, we should of course <em>expose</em> state, in absolute every case.  There must be no real data hiding.  This doesn&#8217;t mean data has to be conveniently accessible &#8212; we can suggest good discipline in the use of data even if we don&#8217;t make it impossible to be undisciplined &#8212; data just has to be&nbsp;accessible.</p>
<p>Here&#8217;s a case in Javascript where there&#8217;s data hiding&nbsp;problems:</p>
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">addDeleteButton</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;&lt;button&gt;x&lt;/button&gt;&quot;</span><span class="p">);</span>
  <span class="nx">button</span><span class="p">.</span><span class="nx">click</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">element</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
  <span class="p">});</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">prepend</span><span class="p">(</span><span class="nx">button</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The <span class="caps">DOM</span> is kind of okay, because you can tell that there&#8217;s a new <code>&lt;button&gt;</code> element in that element.  You can&#8217;t introspect event handlers, but it happens that jQuery does leave evidence of its event listeners.  But if you get to that listener you&#8217;ll get a closure, and you can&#8217;t see the value of <code>element</code> in that&nbsp;closure.</p>
<p>I imagine a language that can, at some moment, take the entirety of its state and save it, and also be able to reconstruct the entirety of that state at will.  Assuming we are using a traditional language with function calls and local variables, this would also imply <a href="http://en.wikipedia.org/wiki/Continuation">continuations</a>.</p>
<p>That&#8217;s cool, of course, and similar to the <a href="http://en.wikipedia.org/wiki/Smalltalk#Image-based_persistence">Smalltalk Image</a>. (I am continually reminding myself of Smalltalk as I think through this language.)  But I want to put this in service of rerunning code more than the more squashy effect of the Smalltalk&nbsp;Image.</p>
<h4>Code&nbsp;coverage</h4>
<p>Code coverage is absolutely necessary, in part because we can&#8217;t understand whether a piece of saved state is still applicable without it.  Has the initialization code associated with a state been changed? If so then we must rewind further, as the state we&#8217;ve saved is something that may represent an old version of the code (and if so, then an undesired version of the&nbsp;state!)</p>
<p>There&#8217;s a lot of places where we want to really work at the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree"><span class="caps">AST</span></a> level. Keeping the source code and the <span class="caps">AST</span> close together may make sense.  To the degree we can comfortably rewrite code into a canonical style, we may be able to make this compatible with text editing, making a fairly intimate feedback between the language and the source, without falling into visual&nbsp;programming.</p>
<h4>Expressions that understand&nbsp;themselves</h4>
<p>I&#8217;d like expressions (and statements, conditionals, etc) to not just be able to execute, but also to be able to give information about what they do; they&#8217;re expectations, what kind of objects they&nbsp;return.</p>
<p>This is usually thought about in terms of types &#8212; expressions are typed, and so you know the types of their input and output (and if you are using <a href="http://en.wikipedia.org/wiki/Exception_handling#Checked_exceptions">checked exceptions</a> you know what kind of exceptions they might&nbsp;produce).</p>
<p>This is useful if you want to know, absolutely <em>know</em>, what the type of something is.  But what if you want to make a pretty good guess? And, if you can run the program, could you run the program until you get to the point when you could actually query all the objects and the bound functions?  The types may not always be quite the same, but I feel this language will not be focused just on guarantees.  It will be focused on <em>momentum</em>.</p>
<p>But types are a digression.  I want to ask functions (and operators and whatever): what kind of return values do you have?  What kind of exceptions?  If it&#8217;s used in a boolean context, what kind of input would provide a true or false value?  Is the output&nbsp;deterministic?</p>
<h4>Detect and fix problems, don&#8217;t completely prevent&nbsp;them</h4>
<p>There&#8217;s guarantees and there&#8217;s predictions.  I would want to explore what we can do with predictions without absolute&nbsp;certainty.</p>
<h3>Integrate testability <em>and</em>&nbsp;tests</h3>
<p>We should be able to do a lot more testing with just some well-placed <code>assert</code> in the code.  The ability to exercise and explore the program in an automated fashion turns sanity-checking into real&nbsp;tests.</p>
<p>But how do we explore a program?  The second part is to make everything mockable.  In some sense that&#8217;s a matter of library design, but then this is a commitment to ubiquitous&nbsp;mocking.</p>
<p>To be fair, we don&#8217;t need to mock everything.  Deterministic and efficient code doesn&#8217;t need to be&nbsp;mocked.</p>
<p>I&#8217;d like to spend a bit of time imagining what that might look&nbsp;like:</p>
<p>In a debuggable program, all code must run.  When you are still in the middle of completing a thought, then no, but everytime you complete a thought you have a program that can be run.  This requires a certain kind of&nbsp;modularity.</p>
<p>Some of the traditional responses to this kind of modularity are things like dependency injection.  Functional programming has some responses as well, as a lack of side effects makes code somewhat more independent.  But I would like the explore the idea of <em>sampling</em>, of having a statistically significant set of data and state, and being able to construct that state at&nbsp;will.</p>
<p>This is somewhat similar to <em>testability</em>.</p>
<p>I am also reminded of <a href="https://en.wikipedia.org/wiki/Design_by_contract">contracts</a>, where you clearly document your expectations and obligations.  But this generally says what you <em>won&#8217;t</em> accept or <em>will not</em> produce, it primarily defines what is illegal.  It does not state what <em>is</em>&nbsp;legal.</p>
<p>When you state what input is legal, expected, and to a degree what category of data you expect, you can actually generate test data, you can generate&nbsp;scenarios.</p>
<p>And so I imagine tests as intrinsic in this language.  You are creating test scenarios as you code, and you are laying out your expectations as you code.  Conventionally you are &#8220;supposed&#8221; to keep your test code separate from &#8220;real&#8221; code, and so I am proposing quite the&nbsp;opposite.</p>
<p>In this debuggable language state would be transparent.  Maybe you can hide state from different parts of the program, but you can never hide it from the programmer.  Something like an opaque closure cannot exist (though a transparent closure could exist!)  Many programming languages have back doors to access this sort of thing, but if it&#8217;s a back door it&#8217;s not part of the language definition.  And of course everyone wants the language to be reflective and self-hosting, so really these special ways of accessing data should be very public.  I can imagine some code running as &#8220;root&#8221; &#8212; with permission to access stuff that normal code doesn&#8217;t, not because you guarantee normal code <em>can&#8217;t</em> access it, but because it is not polite for normal code to access it.  (And perhaps this access should be formally different than normal access, to distinguish code that can be optimized from magic access that keeps many optimizations from&nbsp;happening.)</p>
<p>Once state is fully visible, you have the possibility of freezing and rerunning that state, or exploring the different sets of possible state.  This doesn&#8217;t always work though: how can you update some of the state of the system while leaving others alone, and come up with something consistent?  The most common such update is updating the code itself; in the process you may have made the state impossible, such as fixing code that generated corrupt state that caused a later&nbsp;error.</p>
<p>So another approach is rewinding to a point when everything should be okay and replaying.  So long as everything is deterministic you should get to the same point, or having fixed or extended your code you avoid that bad&nbsp;point.</p>
<p>And then, to make everything deterministic, so you can rerun things. This means everything that isn&#8217;t naturally deterministic is mocked. Mocks everywhere!  Or at least mocks everywhere where there&#8217;s input from the&nbsp;outside.</p>
<p>Sometimes the mocks are something the <span class="caps">API</span> itself can understand.  If you want to mock error handling in file code, file APIs know what kind of exceptions might occur.  If you want to mock reading a file, file APIs are unlikely to know what kind of file contents you might have expected.  And another option is that mockable APIs contain recording options.  All of these are possible and plausible; in a <span class="caps">GUI</span> you might want to record a story, while also randomly executing other stories that can be determined simply by inspecting the controls you&#8217;ve&nbsp;created.</p>
<p>Exercising an application then invites understanding what was exercised.  This implies code coverage as a top-level concept, so stories can be executed to reach new points in the code, or perhaps so you can even introspect and exercise expressions themselves.&nbsp;E.g.:</p>
<div class="highlight"><pre><span></span><span class="err">when save_draft.checked and input.value != saved_value: ...</span>
</pre></div>


<p>If you have magical introspection abilities, you might be able to determine exactly the state required to trigger that condition.  That seems like it would require pretty heroic effort, to understand the types and instantiation of those objects&#8230; but remember, we can allow for runtime introspection, not just static introspection; we can look at <code>save_draft</code> and <code>input</code> and ask them about what they can do, without complicated inference.  Once you have the ability to execute and replay code, you can analyze the live code, not just the dead source code that is waiting to be&nbsp;animated.</p>
<p>I wonder if we might place further burdens on the programmer in the service of this execute-anything principal.  For instance, you as the programmer may know that when <code>save_draft</code> is not visible, it cannot become checked, and maybe you only instantiate <code>input</code> when you make the entire form visible, so evaluating <code>input.value != saved_value</code> would be invalid unless the application was in a very particular state.  And so we cannot just <em>set</em> <code>save_draft.checked</code> to true whenever it pleases the testing daemon.  But perhaps we say that yes, the testing daemon can and will do that, and you just better handle that.  Maybe you have to rewrite that&nbsp;as:</p>
<div class="highlight"><pre><span></span><span class="err">when saved_draft.checked and input and input.value != saved_value:</span>
</pre></div>


<p>even though that condition is impossible outside of testing.  That may be a small price to pay for the other benefits you will accrue from this language.  Or maybe it&#8217;s unnecessary, I&#8217;m not&nbsp;sure.</p></div>
        <!-- /.entry-content -->
  
        <hr />

        <!-- <div>
            Hello! Did you know as of December 2024 I'm looking for a job? <a href="https://www.linkedin.com/feed/update/urn:li:activity:7265435901009231872/">I am!</a> I really like working with LLMs, especially in the domain of education, wellness, and <a href="https://en.wikipedia.org/wiki/Executive_functions">executive function</a>. Maybe <a href="mailto:ianbicking@gmail.com">drop me an email</a>?
        </div> -->
    </article>
</section>
        <section id="extras" class="body">
                <div class="links">
                  <h2><a href="https://ianbicking.org">here</a></h2>
                  <ul>
                    <li><a href="/blog/">blog</a></li>
                    <li><a href="/projects.html">projects</a></li>
                    <li><a href="https://ianbicking.org/archives.html">archives</a> &amp; <a href="https://ianbicking.org/categories.html">categories</a></li>
                    <li><a href="https://ianbicking.org/category/ai.html">category: ai</a></li>
                    <li><a href="https://ianbicking.org/category/javascript.html">category: javascript</a></li>
                    <li><a href="https://ianbicking.org/category/misc.html">category: misc</a></li>
                    <li><a href="https://ianbicking.org/category/mozilla.html">category: mozilla</a></li>
                    </ul>
                </div>
                <div class="social">
                        <h2>elsewhere</h2>
                        <ul>
                            <li><a href="https://ianbicking.org/feeds/atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://hachyderm.io/@ianbicking">@ianbicking@hachyderm.io</a></li>
                            <li><a href="https://bsky.app/profile/ianbicking.org">Blue Sky</a></li>
                            <li><a href="https://www.threads.net/@ibicking">Threads</a></li>
                            <li><a href="https://github.com/ianb">Github</a></li>
                            <li><a href="https://www.linkedin.com/in/ianbicking/">LinkedIn</a></li>
                        </ul>
                </div><!-- /.social -->
                <div class="archives">
                  <h2><a href="https://ianbicking.org/blog/">recent posts</a></h2>
                  <ul>
                    <li><a href="https://ianbicking.org/blog/2025/06/intra-llm-text-adventure.html">Intra: design notes on an <span class="caps">LLM</span>-driven text&nbsp;adventure</a></li>
                    <li><a href="https://ianbicking.org/blog/2025/05/creating-worlds-with-llms.html">Roundup: Creating Worlds with&nbsp;LLMs</a></li>
                    <li><a href="https://ianbicking.org/blog/2025/05/the-hungry-ghost.html">The Hungry&nbsp;Ghost</a></li>
                    <li><a href="https://ianbicking.org/blog/2024/05/ai-aita.html"><span class="caps">AI</span> <span class="caps">AITA</span></a></li>
                    <li><a href="https://ianbicking.org/blog/2024/04/roleplaying-by-llm.html">Roleplaying driven by an <span class="caps">LLM</span>: observations <span class="amp">&amp;</span> open&nbsp;questions</a></li>
                    <li><a href="https://ianbicking.org/blog/2023/04/world-building-gpt-2-declarative.html">World Building with <span class="caps">GPT</span> part 2: bigger, better, more&nbsp;declarative</a></li>
                    <li><a href="https://ianbicking.org/blog/2023/02/world-building-with-gpt.html">World Building With <span class="caps">GPT</span></a></li>
                    <li><a href="https://ianbicking.org/blog/2023/01/thoughts-on-voice-interfaces-2-llms.html">Thoughts On Voice Interfaces 2 years later:&nbsp;LLMs</a></li>
                    <li><a href="https://ianbicking.org/blog/2023/01/infinite-ai-array.html">Infinite <span class="caps">AI</span>&nbsp;Array</a></li>
                    <li><a href="https://ianbicking.org/blog/2020/11/firefox-was-always-enough.html">Firefox Was Always&nbsp;Enough</a></li>
                  </ul>
                </div><!-- /.archives -->

        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
          This is the personal site of <a href="/">Ian Bicking</a>.  The opinions expressed here are my own.
        </footer><!-- /#contentinfo -->

<script src="/theme/instantclick.min.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FKT4HDGBE4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FKT4HDGBE4');
</script>
        </div><!-- /#main-container -->
        </div><!-- /#main-wrapper2 -->
        </div><!-- /#main-wrapper1 -->
</body>
</html>