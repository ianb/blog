<table class='table table-striped'>
<tr><td style='padding-left: 0px' class='dU'>Claudiu</td><td class='dTS'>Thu, 24 Oct 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>Very thoughtful post! I hadn't even though of generic object traversal before. I've wondered about why we still use ASCII to code, though. I feel like languages can be so much better than they are today, but they just aren't. Programming still has far to evolve. But I've thought for a while now that the next step of a language might be one where the editor is as much a part of the language as anything else. Sure ultimately it'll be a text file on disk, preferably a human-readable one (not XML), but it seems some things could be better represented than just blocks of mono-spaced text... maybe at least a nicer way of introducing comments or documentation strings instead of interspersing giant blocks of green or blue or red text in between the code.</p></td></tr>
<tr><td style='padding-left: 50px' class='dU'>Ian Bicking</td><td class='dTS'>Thu, 24 Oct 2013</td></tr>
<tr><td style='padding-left: 50px' colspan='2' class='dMessage'><p>Color Forth! <a href="http://www.colorforth.com/cf.htm" rel="nofollow noopener" title="http://www.colorforth.com/cf.htm">http://www.colorforth.com/c...</a></p><p>With an editable AST you could create tools that allow editing the code while representing it differently.  Make the first occurrence of a variable bold to indicate a variable declaration?  That would be doable.  Highlight a word in such a way to indicate that it is an imported symbol, removing the need to manage import statements?  That would actually be handy!  As I try to come up with examples, I keep getting things that feel more like macros, so I'm not sure where this is going.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>snowmantw</td><td class='dTS'>Thu, 24 Oct 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>"Functional Programming" doesn't mean the program affects nothing, even in the languages like Haskell. Programmers are undoubtful welcome to do things with side-effects, as long as they can isolate and manage those side-effects code reasonably.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>Terry A Davis</td><td class='dTS'>Thu, 24 Oct 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>TempleOS has 8-bit ASCII (IBM screen codes) in the entire tool chain and graphics in source.  I wrote a compiler and grep etc.  You cannot serialize.  <a href="http://www.templeos.org" rel="nofollow noopener" title="http://www.templeos.org">http://www.templeos.org</a></p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>Chris Carpenter</td><td class='dTS'>Thu, 24 Oct 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>Have you tried using common LISP? It allows you to do most/all of the things you are talking about I think. I don't use it myself (yet) but plan on using it soon.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>bgporter</td><td class='dTS'>Fri, 01 Nov 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>w/r/t the visual representation of code, there's actually been a good deal of thought and research into the topic (see for example this book <a href="http://www.amazon.com/Human-Factors-Typography-Readable-Programs/dp/0201107457)" rel="nofollow noopener" title="http://www.amazon.com/Human-Factors-Typography-Readable-Programs/dp/0201107457)">http://www.amazon.com/Human...</a>, but as happens too often in this field, every generation ignores existing research in favor of doing stuff over.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>cfry42</td><td class='dTS'>Fri, 01 Nov 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>This is an extremely important topic and the author has some significant things to say about it. The article is not as coherent as one might hope, but then this is complex stuff. Just getting the ideas out there is great.<br>Here's an attempt to bring a bit of coherency. I'm a language guy so I see things in terms of language. This viewpoint helps simplify and unify.<br>From the article:<br>" Each language’s AST is distinctive, and should be because that’s why we have different languages.  "<br>Basically I think this is wrong. The reason we have different language are:<br>1. To get a language out there, you must implement it. Implementing it is so hard<br>   that implementers have little time left over for actual language design.<br>   So languages tend to be poorly designed because of the complexity of implementation.<br>You must have a small team to do something so complex (and coherent) and a small team<br>usually doesn't have the resources to do decent language design.<br>2. we have an education system that nearly promotes bad language design.<br>Language design isn't taught in universities (Name a course and I'll show you a course that has failed). We encourage different representations for math, music, markup, etc.<br>3. language implementers don't agree on criteria for evaluation. This is not so much<br>a problem that there isn't one good set of criteria as it is an education problem. You need<br>to understand a lot before you can understand what the right criteria are.<br>3. Our economy doesn't support good language design. If you come up with a great idea for a language and you implement it, one of 2 things usually happens: <br>a) Nobody uses it and it dies<br>b) people start using it, then you must maintain backward compatibility and then you can<br>make substantial improvements and you're stuck with a mediocre design.<br>I say mediocre because you can't possibly anticipate all the things you want in a good lang<br>at the outset. <br>4. Fundamentally we need just one language. This solves the worst problems of programming today. But we can't get one because<br>a) lang designers are lousy and don't realize even obviously better ways of doing things<br>b) if a choice is arbitrary, just pick one and stick with it. But how can we do that?<br>If there are multiple reasonable ways of doing X in the world, all of them will exist somewhere.<br>Take "which side of the road should we drive on" for example, or which way should you read,<br>left-to right, right to left, top to bottom? You could say <br>"first person that gets into space X, picks the one choice and everyone else follows it"<br>but the first person usually doesn't pick the best way and we don't have the communication channel (though the web helps a lot).<br>Many would call me arrogant or even stupid for thinking that there can be one right language.<br>Its true that we can't hope to have one language that's the best possible syntax/semantics for<br>every possible domain BUT the interoperability between domains is SO important to<br>nearly every special purpose language (as is learnability), that if we compromise just a <br>bit on some domain-specific optimizations, we can get to one language for pretty much all programming and data representation tasks.<br>What are the key features?<br>We standardize on primitives. For instance, Python uses True and NONE where<br>JavaScript uses true and null. This is just stupid. (I'd go with JS here but it doesn't matter,<br>pick one and stick with it.)<br>OK get the rest of the primitives (numbers, strings, lists out of the way similarly)'<br>Get name-value pairs right with ONE representation:<br>we don't need JSON and Python dicts and hash tables and HTML attribute syntax and<br>CSS syntax.<br>We just need one name-value pair representation, That should work for<br>keyword passing of arguments in function calls too, of course.<br>Object system: use our name-value pairs and declare  the name of "_parent"<br>to be what the data structure uses to inherit from. <br>We'll have a fn call to GET a value from a name value pair, with an optional arg<br>to "lookup" if we want to inherit and another optional arg for a "default" if<br>the name doesn't exist.  We don't need getattr AND foo["bar"] and <br><a href="http://foo.bar" rel="nofollow noopener" title="foo.bar">foo.bar</a> (well maybe the latter is good for a Short cut)<br>And that's pretty much it for the object system.<br>We need flexible function calling that can have required args, optional args with<br>default values, &amp;rest args for unlimited args, and evaluation kinds so that<br><b>some text</b> can be a function call and not break because "some" isn't bound.<br>With the above we can represent control structures, data, anything SQL can do,<br>json like stuff, HTML like markup, etc. <br>Yes there's lots of details (and I've implemented most of them<br>in the language Water) , but we have an amazing resistance from programmers:<br>Guess what? It turns out we're a very conservative bunch. Why? I'd guess it has to<br>do with the shear complexity. Humans get conservative in the face of complexity.<br>Educators are also an extremely conservative bunch too. <br>They want to teach what they know and they know what they learned in school. <br>In general the status quo is conservative. If you are on top you don't want the<br>boat to be rocked. And if you are on top you control education curriculum amongst<br>many other things to maintain the status quo.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>Matthew Fernandez</td><td class='dTS'>Fri, 01 Nov 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>Excellent points all round, Ian. I agree that one of the reasons alternative forms of displaying code haven't really taken off is because text is so good at expressing thought and intent already.</p><p>One of the areas you seem to be alluding to, but don't directly mention is the benefits of optimising compilers; particularly with respect to sequential vs parallel programming. A smarter compiler gives you the ability to write simpler, more readable code, without compromising on performance (c.f. tricks like tail call elimination). We've seen impressive advances in compiler optimisations in the last 20 years and I think there is still plenty of low hanging fruit in this area. A sufficiently clever compiler could even bring us closer to fully declarative code with the performance of imperative code. What are your thoughts about this?</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>Cristobal Dabed</td><td class='dTS'>Fri, 01 Nov 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>The funny thing about programming these days that we keep re-implementing stuff invented 30-40years ago. Functional programming concepts are more actual than ever, even co routines are back.</p><p>Interesting that you mentioned ZeroVm, Emerald a lesser know programming language <a href="http://en.wikipedia.org/wiki/Emerald_(programming_language)" rel="nofollow noopener" title="http://en.wikipedia.org/wiki/Emerald_(programming_language)">http://en.wikipedia.org/wik...</a>, did this already in the early 80s. However how reliable is reliable it was programmed such that the processes moved across the computers. The closed i have seen anything like this these days is Puppet or Chef when deploying environments to nodes (servers) still you are not moving pure processes around but you have the concept of nodes.</p><p>Perhaps most concepts invented 30-40years ago where too far ahead of its time ;)</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>Tristan Slominski</td><td class='dTS'>Sat, 09 Nov 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>One pet peeve... in section "procedures -&gt; goals and constraints" *objects* are simply assumed as a good idea in the first place. Worse yet, that enumerating object properties is a good idea. Both of those implied assumptions severely limit the solution space... consider, for example, actors, or object capabilities to contrast.</p></td></tr>
<tr><td style='padding-left: 50px' class='dU'>Ian Bicking</td><td class='dTS'>Sun, 10 Nov 2013</td></tr>
<tr><td style='padding-left: 50px' colspan='2' class='dMessage'><p>If you'd like to speculate in detail what it would mean to query actors or object capabilities, I'm all ears!</p></td></tr>
<tr><td style='padding-left: 100px' class='dU'>Tristan Slominski</td><td class='dTS'>Sun, 10 Nov 2013</td></tr>
<tr><td style='padding-left: 100px' colspan='2' class='dMessage'><p>One does not simply query actors or object capabilities... :)</p><p>From re-reading that section, it seems to me that the proposal calls for adding things to the objects themselves in order to support querying and traversal. The problem I see with this that in a run-time environment, this is a source of security issues of the "I'm not able to sandbox code" kind to the "I cannot reason about security of what has access to what anymore" kind. I am also referring to a type of security impossible in Python in the first place, so it's hard to fit this into that environment.</p><p>Consider an alternative model (inspired by actors and object capabilities (OCap)). Due to the nature of actors and OCap, they can't be queried or reveal their state by traversal.. well, they shouldn't because anyone could do that leading to poor security. But, accepting this constraint, what can then be done in an IDEnvironment? One proposal would be object proxies, and this could maybe be carried over perhaps into the python ideas you used as an example. There could be super-powerful security-breaking proxies in an IDE that allow you to reason about objects, however upon compilation/release (whatever that means in such a system), these are stripped away so that one cannot query or enumerate on objects. Source code distribution would include proxies... run-time distribution would not. I'll give this more thought, it's intriguing.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>Tenn Leeuwenburg</td><td class='dTS'>Fri, 15 Nov 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>I think that programming isn't futuristic mainly because of the fact it's more about procedures than goals. I think our goal in the industry should be to continually strive to lift the level at which we work. However, much of that is as much about data as it is about code, as much about the scaffolding as the construction. Much of the complexity in our data comes about from the complexity of the world, but also from the organic nature of constructing things. I think for software construction to become more futuristic, we need more robust means of interactive with data.</p></td></tr>
<tr><td style='padding-left: 0px' class='dU'>collinmanderson</td><td class='dTS'>Tue, 10 Dec 2013</td></tr>
<tr><td style='padding-left: 0px' colspan='2' class='dMessage'><p>typo: "from left to write"</p></td></tr>
</table>
