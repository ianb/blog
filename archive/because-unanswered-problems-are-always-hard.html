<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>Because Unanswered Problems Are Always Hard</title>
        <link rel="stylesheet" href="WK/default.css" type="text/css" />
        <link
            rel="alternate"
            type="application/rss+xml"
            title="New Posts"
            href="https://ianbicking.org/feeds/new_pages.xml"
        />
    </head>
    <body color="black" bgcolor="white">
        <h1 id="header">
            <a href="index.html">Ian Bicking: the old part of his blog</a>
        </h1>

        <div style="float: right">
            <script type="text/javascript">
                google_ad_client = "pub-2913402032659646";
                google_ad_width = 120;
                google_ad_height = 600;
                google_ad_format = "120x600_as";
                google_ad_type = "text";
                google_ad_channel = "";
                google_color_border = "336699";
                google_color_bg = "FFFFFF";
                google_color_link = "0000FF";
                google_color_text = "000000";
                google_color_url = "008000";
                //-->
            </script>

            <script src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
        </div>
        <h1>Because Unanswered Problems Are Always Hard</h1>

        <div class="document">
            <p>
                I was reading through Bruce Eckel's
                <a class="reference" href="http://mindview.net/WebLog/log-0066"
                    >Static vs. Dynamic</a
                >, which repeats a message we see many places in many forms:
                <em
                    >This last point is a major puzzle -- we believe that static
                    type checking prevents bugs, and yet a dynamically-typed
                    language produces very good results anyway.</em
                >
            </p>
            <p>
                There's a couple reasons, like a good language for rapid
                prototyping leaves you more time to debug, or more time to use
                good practices early on (like unit testing and continuous
                refactoring). But then it might just be a wash, if it leaves us
                more time to fix our problems, it still might be the same
                distance to &quot;finished&quot;. I think this is the case for
                Perl and PHP, but not for other dynamic languages like Python,
                Smalltalk, Ruby, Lisp.
            </p>
            <p>
                The difference being a really high-level language, and just a
                dynamic language: I don't think Perl and PHP are really
                high-level. Which is to say, there is a limit to how far you can
                build abstractions. Regular expressions are an excellent
                example. They are really nice, especially if you compare it to C
                string handling. But once you have them, they don't
                <em>lead</em> anywhere. They are one tool among many, and while
                they are useful, at some point programs need to move to a higher
                level where that kind of string manipulation is an incidental
                (and replaceable) implementation detail. So Perl seemed hot when
                regular expressions were cutting edge, but it loses momentum now
                that they are widely usable in all decent programming
                environments.
            </p>
            <p>
                When reading Phillip's
                <a
                    class="reference"
                    href="http://dirtsimple.org/2004/12/python-is-not-java.html"
                    >Python Is Not Java</a
                >, the basic message is really: aim higher. You've been given a
                high-level language (finally!), so make use of it, otherwise the
                improvements will only be nominal.
            </p>
            <p>
                Back to reliability: one way to decrease bugs is testing, but
                another way is to decrease the amount of code. Code deleted is
                code debugged. Static typing can decrease the number of bugs,
                but decreasing the amount of code is a much, much more effective
                way to decrease bugs. If you can have both -- short code and
                static typing -- then more power to you. I just haven't seen it
                myself.
            </p>
            <p>
                I think this is in part because types aren't actually that
                interesting. People often talk about the four attributes:
                dynamic typing (Python) vs. static typing (Java), and weakly
                typed (C) vs. strongly typed (Python or Java). Now forgotten, at
                one time there were languages that were both weakly typed
                <em>and</em> dynamically typed; things like assembly and Forth.
                Ouch. There were two paths from there: one to make runtime
                values intrinsically typed (Lisp), and one to make the source
                code intrinsically typed (C). But just because assembly sucked
                <em>a lot</em> doesn't mean all languages afterward must
                approach the problem in terms of its suckage. And just because
                there was that split, doesn't mean joining both worlds (a
                language with both intrinsically typed values and source, i.e.
                Java) is better. And luckily you can't take intrinsically typed
                values any further; once you've accomplished it, your work is
                over, values can't be <em>more</em> intrinsically typed.
                Intrinsically typed source is really hard, and it's an
                unfinished job; ML, Haskell, and their progeny continue the
                work, but it's clearly not finished.
            </p>
            <p>
                So here we we are, the dynamic languages have finished the work
                on types (at least the work <em>we</em> choose to do). We moved
                on a long time ago (well, <em>they</em> moved on with Lisp when
                I was still a child, long before I could consider myself a
                member of any <em>we</em>), and we've been moving on to other
                techniques of higher level programming while statically typed
                languages have languished. <em>That</em> is why I believe
                dynamically typed languages are better, simply because it
                addressed a real problem (weak dynamic languages) in a solvable
                way.
            </p>
            <p>
                Static typing won't lead to less bugs, because hard problems are
                still hard.
                <em
                    >Any sufficiently complicated C or Fortran program contains
                    an ad-hoc, informally-specified, bug-ridden, slow
                    implementation of half of Common Lisp</em
                >
                (<a
                    class="reference"
                    href="http://c2.com/cgi/wiki?GreenspunsTenthRuleOfProgramming"
                    >source</a
                >). In part that's a defense of a big standard library, but it's
                also a defense of high level programming. Low-level languages
                don't just reimplement specifics, like hash tables or regular
                expressions, but there's a loss of many abstractions because you
                <em>can't</em> express some concepts in low-level languages in a
                way that is reusable. Static type defenders complain about the
                combinatorial type interactions in dynamically typed languages
                -- how can you test all the code paths, given all the possible
                types? But their languages lead to combinatorial <em>code</em>,
                which is far worse: for many classes of hard problems, they
                can't solve them once, they have to solve them everytime they
                are encountered. Ouch. Dynamic typing isn't the solution, it's
                just the best place we have to start from if we're looking for a
                solution.
            </p>
            <p>
                Maybe part of the problem is a lack of imagination. People ask
                <em>which system is the right system?</em> when the answer
                should clearly be <em>none</em>. Rather we must ask
                <em
                    >which system has the most potential for leading us towards
                    the right system?</em
                >
                To advocate any system as The Right Way is as absurd as it is
                obnoxious; as long as there are unanswered problems we haven't
                figured out the Right Way.
            </p>
        </div>
        <div class="dates" align="right">
            Created 15 Dec '04<br />
            Modified 12 Jul '05
        </div>
        <hr noshade />
        <h3 id="comments">Comments:</h3>
        <blockquote>
            <div class="document">
                <p>
                    Quote: &quot;If you can have both -- short code and static
                    typing -- then more power to you. I just haven't seen it
                    myself.&quot;
                </p>
                <p>
                    Take a look at Haskell (<a
                        class="reference"
                        href="http://haskell.org/"
                        >http://haskell.org/</a
                    >). Automatic static typing, with very concise, but yet very
                    readable syntax. And you get to eliminate all the bugs
                    associated with side-effects (like state and specifying
                    order of evaluation).
                </p>
            </div>
            <div align="right">
                <a
                    href="https://ianbicking.org/because-unanswered-problems-are-always-hard-comment-1.html"
                    rel="nofollow"
                    >#</a
                >
                Greg Buchholz
            </div>
            <hr noshade />

            <div class="document">
                <p>
                    Quote: &quot;I don't think Perl and PHP are really
                    high-level.&quot;
                </p>
                <p>
                    <a
                        class="reference"
                        href="http://okmij.org/ftp/Perl/Scheme-in-Perl.txt"
                        >http://okmij.org/ftp/Perl/Scheme-in-Perl.txt</a
                    >
                </p>
                <p>
                    &quot;There is an often-quoted saying by Guy L. Steele Jr.:
                    &quot;If you give someone Fortran, he has Fortran. If you
                    give someone Lisp, he has any language he pleases.&quot; It
                    appears that for some languages, the converse is also true.
                    If you give someone this language, he has Lisp. Thinking in
                    a recursive, functional style indeed has advantages; for
                    example, it meshes well with a problem decomposition, a
                    divide-and-conquer approach. The other result of this
                    exercise is to make me appreciate more the syntax of Scheme
                    -- or the lack of it.&quot;
                </p>
            </div>
            <div align="right">
                <a
                    href="https://ianbicking.org/because-unanswered-problems-are-always-hard-comment-2.html"
                    rel="nofollow"
                    >#</a
                >
                <a href="http://">Greg Buchholz</a>
            </div>
            <hr noshade />

            <div class="document">
                <p>
                    It seems me that a variation of the Lisp quote is also true.
                    Any sufficiently large program written in a dynamically
                    typed language will eventually end up reimplementing
                    type-checking, badly. The largest Python system I know of is
                    Zope, and it's very complicated, has reimplemented Java
                    interfaces, and is generally harder to understand than a
                    well-written Java web app written in plain old Java classes.
                </p>
                <p>
                    I also have yet to see a team get good results using a
                    dynamic language. It's very nice for the lone coder writing
                    a small program, but...
                </p>
            </div>
            <div align="right">
                <a
                    href="https://ianbicking.org/because-unanswered-problems-are-always-hard-comment-3.html"
                    rel="nofollow"
                    >#</a
                >
                <a href="http://slesinsky.org/brian/">Brian Slesinsky</a>
            </div>
            <hr noshade />
        </blockquote>
        <script
            src="http://www.google-analytics.com/urchin.js"
            type="text/javascript"
        ></script>
        <script type="text/javascript">
            _uacct = "UA-2442258-1";
            urchinTracker();
        </script>
    </body>
</html>
