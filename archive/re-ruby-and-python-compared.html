<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Re: Ruby and Python Compared</title>
<link rel="stylesheet" href="WK/default.css" type="text/css">
<link rel="alternate" type="application/rss+xml" title="New Posts" href="http://blog.ianbicking.org/feeds/new_pages.xml">

<link rel="openid.server" href="http://www.myopenid.com/server" />
<link rel="openid.delegate" href="http://ianb.myopenid.com" />

</head>
<body color="black" bgcolor="white">
<!-- Help menus: -->
<div id="menu_3" class="menu" onmouseover="menuMouseover(event)">
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/thiswiki.html">About this wiki</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/quickresthelp.html">Help with markup</a>
<div class="menuItemSep"></div>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/relatedterms.html">Related terms</a>
</div>
<!-- <b>Re: Ruby and P&#8230;</b> menus: -->
<div id="menu_1" class="menu" onmouseover="menuMouseover(event)">
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/rerubyandpythoncompared.html">View</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/re-ruby-and-python-compared.txt">Source</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/rerubyandpythoncompared.html?_action_=backlinks">Backlinks</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/rerubyandpythoncompared.html?_action_=history">History</a>
</div>
<!-- Goto menus: -->
<div id="menu_2" class="menu" onmouseover="menuMouseover(event)">
<a class="menuItem" rel="nofollow" href="index.html">Home</a>
<a class="menuItem" rel="nofollow" href="archive/index.html">Archive of Posts</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/recentchanges">Recent Changes</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/orphans">Orphaned Pages</a>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/wanted">Wanted Pages</a>
<a class="menuItem" rel="nofollow" href="http://www.technorati.com/claim/6v7x9jhkxz">Technorati Profile</a>
<div class="menuItemSep"></div>
<a class="menuItem" rel="nofollow" href="http://blog.ianbicking.org/login?returnTo=/re-ruby-and-python-compared.html">Login</a>
</div>
<form action="http://blog.ianbicking.org/search" method="GET"><div class="menuBar">
<span style="color: #000099">Wiki:</span><a class="menuButton" rel="nofollow" href="re-ruby-and-python-compared.html" onclick="return buttonClick(event, 'menu_1')" onmouseover="buttonMouseover(event, 'menu_1')"><b>Re: Ruby and P&#8230;</b></a>
<a class="menuButton" rel="nofollow" href="re-ruby-and-python-compared.html" onclick="return buttonClick(event, 'menu_2')" onmouseover="buttonMouseover(event, 'menu_2')">Goto</a>
<a class="menuButton" rel="nofollow" href="re-ruby-and-python-compared.html" onclick="return buttonClick(event, 'menu_3')" onmouseover="buttonMouseover(event, 'menu_3')">Help</a>
</div></form>
<div style="float: right">

<script type="text/javascript">google_ad_client = "pub-2913402032659646";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
google_ad_channel ="";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>

 <script src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</div><h1>Re: Ruby and Python Compared</h1>
 
<div class="document">
<p>In regards to <a class="reference" href="http://www.rexx.com/~oinkoink/Ruby_v_Python.html">Ruby and Python Compared</a>:</p>
<blockquote>
Larry Wall, the designer of Perl, has the slogan &quot;There's more
than one way to do it&quot;. In contrast, Bertrand Meyer, the designer
of Eiffel, says &quot;A programming language should provide one good
way of performing any operation of interest; it should avoid
providing two.&quot; Ruby follows the anarchist approach of Larry Wall,
while Python follows the bondage-and- discipline approach of
Eiffel.</blockquote>
<p>Python is not in any way a B&amp;D language.  At all.  Even slightly.  No
resemblence.  It takes nothing from Eiffel.  It probably <em>could</em> take
some good ideas, but right now it doesn't even take any of its good
ideas.</p>
<p>Python attempts to build consistency with a carrot approach, not a
stick.  I say &quot;attempts&quot; because there are many places where the
Python community doesn't agree on a solution, doesn't agree on the
phrasing of the problem, or simply doesn't know the best way to do
things.  There will always be such places, until such time as all
programming problems are solved.  Despite the futility of this effort,
we still pursue compelling, complete, and consistent solutions.</p>
<p>An important rule in the Python community is: we are all consenting adults.  That is,
it is not the responsibility of the language designer or library author
to keep people from doing bad things.  It is their responsibility to prevent
people doing bad things <em>accidentally</em>.  But if you really want to do something
bad, who are we to say you are wrong?  It's your program.  Maybe you even have
a good reason.</p>
<p>That said, it's unlikely you'll see language designers or library authors going
out of their way to <em>enable</em> you to do bad things where it was previously
impossible.  So some feature suggestions that are likely to cause errors are
unlikely to get much consideration.</p>
<blockquote>
Python usually seems to have one best way to perform a given task,
and even prescribes how the code is to be laid out, since
indentation is syntactically significant.</blockquote>
<p>Of course you'd have to be nutty not to indent your code the way
Python wants you to.  Python is DRY (Don't Repeat Yourself) here.</p>
<blockquote>
Ruby's treatment of Booleans is much cleaner. In ruby, false and
nil are considered false in boolean contexts, and everything else
is considered true. Python follows the antimathematical convention
of C and Perl where 0 is considered false. This nonsense really
has no place in such a high-level language. But Python makes
things worse: empty lists, empty dictionaries, and empty tuples
are false. What about empty sets? Well, sets are not a built-in
type, so it depends on how they are implemented. Python lacks true
booleans: true and false.</blockquote>
<p>I don't think this is a very meaningful comparison.  If you want to
test for nil/None, test for nil/None.  I guess you could say that Ruby
is like Scheme or Smalltalk, and Python more like Lisp.  There's points
for and against each technique, but smart people have and continue to go
both ways; just get used to it.</p>
<p>That <tt class="docutils literal"><span class="pre">False</span> <span class="pre">==</span> <span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">True</span> <span class="pre">==</span> <span class="pre">1</span></tt> is an artifact of a time when
Python lacked true booleans (though <em>now</em> <tt class="docutils literal"><span class="pre">True</span></tt> and <tt class="docutils literal"><span class="pre">False</span></tt> are
&quot;true&quot; booleans, even if they are also integers: <tt class="docutils literal"><span class="pre">False</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">0</span></tt>).  While the
underlying integer nature of True and False lacks elegance, I haven't
had any problems with it in practice.</p>
<p>As for other things being false (I use a lower-case &quot;false&quot; to refer
to all falsish items in Python), this is just how Python is.
Falseness is a property of an object.  Empty sets are false, because
thats how they are implemented.  <em>Convention</em>, not the <em>language</em>,
enforces the greater concept of what is &quot;false&quot;.</p>
<blockquote>
In C, 7/3 is 2. I'm really a mathematician rather than a
programmer, so I feel that 7/3 should be the rational number
7/3. The earlier versions of Python followed the C
convention. Happily, Python has finally switched. Ruby defaults to
the C convention but also gives the ordinary convention for
rationals when you require the mathn standard library. I always
require the mathn standard library!</blockquote>
<p>In Python <tt class="docutils literal"><span class="pre">7/3</span></tt> is still <tt class="docutils literal"><span class="pre">2</span></tt>.  It probably will be until Python
3.0; Guido regrets the original decision, but changing it before 3.0
is way too big a problem.  This isn't a reflection of some deep design
principle in the language.</p>
<p>Python does not allow a library to change what <tt class="docutils literal"><span class="pre">7/3</span></tt> evaluates to.
Here Python the language is taking over, where in Ruby a library can
effect this.  I assume in Ruby that means -- when the <tt class="docutils literal"><span class="pre">mathn</span></tt>
library is loaded -- that division of all integers produces rationals...?
But that seems so incredibly broken that I must assume it is not so.</p>
<blockquote>
Python's OO has become more extensive in recent versions, but it
is still an OO bolt-on to a procedural language. Ruby is
thoroughly OO. In Python, it is rather arbitrary whether some
functionality is implemented by a function or a method (which have
different syntaxes), and the programmer just has to remember how
Python does it. Python has types and classes; in Ruby types are
classes.</blockquote>
<p>It's not &quot;arbitrary,&quot; it's an aspect of whatever thing you are using.
Not all libraries are designed the same, not all libraries are well
designed, so sometimes a method is chosen when a function would do, or
vice versa.  You can make the same choices in Ruby.  As a <em>convention</em>
people in Ruby use methods far more often.  Over time I personally
have come to use functions more often than methods, only using methods
if I see that a compelling object has emerged in my code.  This is a
difference of opinion.  But Python isn't the only place where people
are starting to feel more disaffected with class-based OO, though
really it's an aside to the particulars of the language.</p>
<p>The distinction between classes (read: old-style classes) and types
(read: built-in types, types written in C, new-style classes) is
subtle and related to legacy.  The distinction should disappear in
3.0, and you can mostly ignore it in current versions as well.</p>
<blockquote>
Until recently, Python's multiple inheritance had a critical
design flaw which made it useless except as a way of implementing
mixins. Whether the improved multiple inheritance will buy Python
anything besides confusion has yet to be seen.</blockquote>
<p>If it doesn't work for you, don't use it.  In practice very few people
use multiple inheritance anyway.  Whatever.</p>
<blockquote>
But Ruby's thorough, dynamic OO gives the programmer incredible
power. Methods can be easily added or removed from classes at
run-time. They can easily added or removed from individual
objects!</blockquote>
<p>This can be done in Python as well, though it does not have the
syntactic support that Ruby has.  Some Python classes, including many
built-in classes, are not possible to extend.  Extending core classes
is a highly questionable practice in my mind -- useful for clever
hacks, but not for serious programming.</p>
<blockquote>
There is direct support for popular design patterns such as
&quot;Observer&quot;, &quot;Delegator&quot;, &quot;Singleton&quot;, &quot;Visitor&quot;.</blockquote>
<p>This is true; Python does not have any specific culture around these
patterns.  Though some patterns like &quot;Singleton&quot; are total nonsense
anyway.  But then, I don't really know what the support in Ruby looks
like, so I don't know how I'd recognize it in Python.</p>
<blockquote>
A Ruby program has great capacity for &quot;reflection&quot;, the ability to
observe itself. Want a list of all living objects belonging to a
particular class? No problem! Should you enjoy life in the fast
lane, a ruby program can effectively rewrite itself at run-time.</blockquote>
<p>Python's reflection is quite good.  The list of all living objects,
however, does not exist.</p>
<blockquote>
Python's garbage collection is based on reference-
counting. Ruby's is mark-and-sweep (scheduled to be replaced by a
generation-based system). Python's system allows the programmer
more direct control over garbage collection: the del operator
tells Python to garbage-collect a specific object right now. But
Python's reference-counting system can easily lead to memory
leaks, especially when trying to interface with C-code. Little
rings of co-referential dead objects can accumulate with a
long-running Python program.</blockquote>
<p>This is not true.</p>
<blockquote>
Ruby is capable of Perl-like one-liners that can be used on the
command line for system administration. Python is unsuitable for
this.</blockquote>
<p>Hey, <a class="reference" href="http://www.pycontest.net/ranking/">one liners work in Python too</a>.  Generally speaking, Python is
a very popular system administration language; certainly Perl is still
king, but at least in the Linux world Python is the clear
up-and-coming system administration language.</p>
</div>
 <div class="dates" align="right">
Created 12 Apr '06</div>
<hr noshade><h3 id="comments">Comments:</h3>
<blockquote>
 
<div class="document">
<p>Singleton is Total Nonsense? Hmmm...</p>
<dl class="docutils">
<dt>class _MasterRegistry(object):</dt>
<dd>&quot;&quot;&quot;
This singleton holds all the class registries.  There can be
multiple registries to hold different unrelated sets of classes
that reside in the same process.  These registries are named with
strings, and are created on demand.  The MasterRegistry module
global holds the singleton.
&quot;&quot;&quot;</dd>
</dl>
<p>Where have I seen that...</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-1.html" rel="nofollow">#</a> <a href="http://www.almad.net">Almad</a></div><hr noshade>
 <blockquote><blockquote>
A Ruby program has great capacity for "reflection", the ability to observe itself. Want a list of all living objects belonging to a particular class? No problem! Should you enjoy life in the fast lane, a ruby program can effectively rewrite itself at run-time.</blockquote>
Python's reflection is quite good. The list of all living objects, however, does not exist.</blockquote>

You can, however, make a class that can provide a list of all living instances. That's what I did when I hacked Routes support into web.py:

<pre>
class controller(object):
    registry = {}
    class __metaclass__(type): 
        def __init__(cls, name, bases, dict): 
            if not ('register' in dict):
                cls.register(cls) 
            return
    @classmethod
    def register(cls, thecls):
        cls.registry[thecls.__name__] = thecls
        return
    @classmethod
    def subclasses(cls):
        return cls.registry.keys()
</pre>

Yeah, it's ugly. But it works.
 <div align="right"><a href="http://blog.ianbicking.org/rerubyandpythoncomparedcomment2.html" rel="nofollow">#</a> <a href="http://www.inklesspen.com">Jon Rosebaugh</a></div><hr noshade>
<blockquote>
 
<div class="document">
<p>That's to find all subclasses, not all instances.  I remembered about the <a class="reference" href="http://python.org/doc/current/lib/module-gc.html">gc</a> module, though, and this kind of works:</p>
<pre class="literal-block">
def all_instances(a_class):
    return [obj for obj in gc.get_objects() if isinstance(obj, a_class)]
</pre>
<p>People use things like this to do reloading in Python.  Once someone says &quot;yes, I do reloading, and it works like a dream and never fails&quot; then I'll be all over that.  But it seems like there's some other tricks to do it right.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/rerubyandpythoncompared-comment-3.html" rel="nofollow">#</a> Ian Bicking</div><hr noshade>
<blockquote>
 
<div class="document">
<p>Whups, yeah.</p>
<p>A similar principle would work, though.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/rerubyandpythoncompared-comment-4.html" rel="nofollow">#</a> <a href="http://www.inklesspen.com">Jon Rosebaugh</a></div><hr noshade>
</blockquote>
 
<div class="document">
<p>&quot;Yeah, it's ugly. But it works.&quot;</p>
<p>That's the point. Ruby does it with elegance.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/rerubyandpythoncompared-comment-20.html" rel="nofollow">#</a> <a href="http://dan.chokola.com/">Dan Chokola</a></div><hr noshade>
</blockquote>
 
<div class="document">
<p>&quot;As a convention people in Ruby use methods far more often.&quot;</p>
<p>Because there are no standalone functions in Ruby.  Things like &quot;puts&quot; look like functions, but are actually instance methods of Kernel.  <a class="reference" href="http://dev.rubycentral.com/faq/rubyfaq-7.html">http://dev.rubycentral.com/faq/rubyfaq-7.html</a></p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-5.html" rel="nofollow">#</a> Robert</div><hr noshade>
 
<div class="document">
<p>&quot;This nonsense really has no place in such a high-level language. But Python makes things worse: empty lists, empty dictionaries, and empty tuples are false. &quot;</p>
<p>This is one of my favorite python features, the fact that &quot;if something:&quot; will always do the right thing. Isn't this the whole point of using a high level language in the first place? :-)</p>
<p>I don't want to write &quot;if lst.is_empty?&quot; or &quot;if len(lst)&quot; - oh wait, 0 shouldn't be False so this should be &quot;if len(lst)==0&quot;, right?</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-6.html" rel="nofollow">#</a> Justin</div><hr noshade>
 
<div class="document">
<p>Hey, Ian, I already replied to this one on my blog too!</p>
<p><a class="reference" href="http://faassen.n--tree.net/blog/view/weblog/2006/04/12/0">http://faassen.n--tree.net/blog/view/weblog/2006/04/12/0</a></p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-7.html" rel="nofollow">#</a> Martijn Faassen</div><hr noshade>
 
<div class="document">
<p>Ian, It was gracious of you to analyze and counter oinkoink's article point-by-point, rather than just summing it up as a steaming pile of crap. :-)</p>
<p>Re: one-liners on the command line. I published a little script at the Cookbook site (<a class="reference" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/437932">pyline</a>) that lets you write ad-hoc CLI scripts in Python, suitable for piping. E.g. to print the md5 sum of all .py files in the current directory, you could (use md5sum, or you could) write:</p>
<pre class="literal-block">
ls *.py | pyline -m md5 &quot;'%s %s' % (md5.new(file(line).read()).hexdigest(), line)&quot;
</pre>
<p>Prettier than Perl, though not by much. But Python is certainly suitable for CLI use.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-8.html" rel="nofollow">#</a> Graham</div><hr noshade>
 
<div class="document">
<pre class="doctest-block">
&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; 7/3
2.3333333333333335
</pre>
<p>not exactly a library, but it's a provisional feature</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-9.html" rel="nofollow">#</a> <a href="http://www.divmod.org">Moe Aboulkheir</a></div><hr noshade>
 
<div class="document">
<blockquote>
<p>In Python 7/3 is still 2. It probably will be until Python 3.0; Guido regrets the original decision, but changing it before 3.0 is way too big a problem. This isn't a reflection of some deep design principle in the language.</p>
<p>Python does not allow a library to change what 7/3 evaluates to. Here Python the language is taking over, where in Ruby a library can effect this.</p>
</blockquote>
<p>This program:</p>
<p>from __future__ import division</p>
<p>print 7/3</p>
<p>prints out 2.33333333 in Python 2.3 and newer. And 7//3 gives the old division behaviour which produces 2.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-10.html" rel="nofollow">#</a> <a href="http://">hanz</a></div><hr noshade>
<blockquote>
 
<div class="document">
<p>But it won't change the behaviour of / operator in other modules.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-12.html" rel="nofollow">#</a> Baczek</div><hr noshade>
</blockquote>
 
<div class="document">
<blockquote>
I guess you could say that Ruby is like Scheme or Smalltalk, and Python more like Lisp.</blockquote>
<p>This is incorrect. Ruby's setup is similar to Scheme's, except that NIL is not false in Scheme. However, in Lisp, NIL is the only false value, and there is no boolean type, with T used to represent truth only by convention. This is not in any way similar to Python's behavior.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-11.html" rel="nofollow">#</a> Nick Thomas</div><hr noshade>
 
<div class="document">
<p>This article was thoroughly disappointing, especially given Mr. Bicking's involvement in the Python community. I wrote a full response to this article <a class="reference" href="http://dan.chokola.com/journal/?user=dan&amp;entry=2007-01-27.105426">here</a>.</p>
</div>
 <div align="right"><a href="http://blog.ianbicking.org/re-ruby-and-python-compared-comment-21.html" rel="nofollow">#</a> <a href="http://dan.chokola.com/">Dan Chokola</a></div><hr noshade>
</blockquote>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-2442258-1";
urchinTracker();
</script></body>
</html>
