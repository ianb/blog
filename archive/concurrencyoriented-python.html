<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Concurrency-Oriented Python</title>
<link rel="stylesheet" href="WK/default.css" type="text/css">
<link rel="alternate" type="application/rss+xml" title="New Posts" href="http://blog.ianbicking.org/feeds/new_pages.xml">

<link rel="openid.server" href="http://www.myopenid.com/server" />
<link rel="openid.delegate" href="http://ianb.myopenid.com" />

</head>
<body color="black" bgcolor="white">
<h1 id="header"><a href="index.html">Ian Bicking: the old part of his blog</a></h1>

<div style="float: right">

<script type="text/javascript">google_ad_client = "pub-2913402032659646";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
google_ad_channel ="";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//--></script>

 <script src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</div><h1>Concurrency-Oriented Python</h1>
 <p>In <a href="http://lambda.weblogs.com/discuss/msgReader$9289">Concurrency-oriented programming</a> Peter Van Roy talks (briefly) about concurrency as a basis for functional programming.  I like Python as a multi-paradigm language (sometimes procedural, sometimes OO, sometimes prototype-based, sometimes class... and on it goes).  Can some of the techniques of Oz and Erlang also be implemented in Python?  (In <a href="http://www.stackless.com/">Stackless?</a>)

<p> I guess that means I'll have to learn Oz or Erlang before I'll know.  (Which one?)  There seems to be an emphasis on strict functional programming in both, such that the programmer is not only assisted in concurrent programming, but moreso they are forced to do clean concurrent programming.  I/O always seems painful in a strictly functional environment, as it is very non-functional; <a href="http://blog.colorstudy.com/ianb/weblog/2003/07/11.html#P5">computations are correct, not programs</a> -- but functional and declarative programming tries to hide computation.

<p> Anyway, a direction for further exploration...
 <div class="dates" align="right">
Created 21 Oct '03<br>
Modified 14 Dec '04</div>
<hr noshade><h3 id="comments">Comments:</h3>
<blockquote>
 Stackless is probably the thing you want to check out (speacking of checking out: the stackless website is really not 
<br />
up to date anymore and the cvs address has changed to:
<br />
CVSROOT=:pserver:anonymous@centera.de/home/cvs
<br />
export CVSROOT
<br />
cvs login
<br />
cvs co stackless
<br />

<br />
What is possible now, is to have "tasklets" than run as light weight threads. Communication is done
<br />
via so called "channels". Tasklets can be pickled and saved for later use.
<br />

<br />
For now, it is not possible to use this in distributed computing environments, but there are definatelly
<br />
plans for that. At the moment, stackless is based on python 2.2.3 . Porting to python 2.3 might take a
<br />
while.
<br />
It might happen that stackless won't be continued as such, but integrated into the pypy (python in python).
<br />
See <a href="http://codespeak.net" target="_blank">http://codespeak.net</a> for further info on that.
 <div align="right"><a href="http://blog.ianbicking.org/comment460.html" rel="nofollow">#</a> Stephan Diehl</div><hr noshade>
 I'm afraid that I haven't worked with Oz, so can't comment too much. I've done some workon Erlang, however, and would have to rate it as a good choice for certain types of application (it's great for state machines and protocol stacks - no great surprise given where it came from).
<br />

<br />
Erlang does have the advantage that it is a reasonably mature system - there are industrial scale telecomms and networking systems (mostly embedded) out there which use Erlang, and work very well.
<br />

<br />
It's worth remembering that Erlang grew out of Ericsson's need to try to streamline its won development and software QA issues, and so addresses particularly successfully some of the main preoccupations in telecomms networking: very high availability and reload of software on the fly. 
<br />

<br />
On a personal note, I find that Erlang appeals to the same part of my brain which loves working in Python, although it is, of course, very different in look and feel...
 <div align="right"><a href="http://blog.ianbicking.org/comment461.html" rel="nofollow">#</a> Jeremy O'Donoghue</div><hr noshade>
 You may also want to have a look at the Python-Logic SIG at <a href="http://www.logilab.org/projects/python-logic" target="_blank">http://www.logilab.org/projects/python-logic</a> and at the new python-in-python interpreter that is in the works and will implement both stackless and psyco features, as well as many others (see <a href="http://codespeak.net/pypy)." target="_blank">http://codespeak.net/pypy).</a>
 <div align="right"><a href="http://blog.ianbicking.org/comment462.html" rel="nofollow">#</a> <a href="http://www.logilab.org/">Nicolas</a></div><hr noshade>
</blockquote>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-2442258-1";
urchinTracker();
</script></body>
</html>
